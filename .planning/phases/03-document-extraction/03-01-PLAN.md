---
phase: 03-document-extraction
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/errors.ts
  - lib/document-extraction/types.ts
  - lib/document-extraction/pdf-extractor.ts
  - lib/document-extraction/docx-extractor.ts
  - lib/document-extraction/validators.ts
  - lib/document-extraction/index.ts
autonomous: true

must_haves:
  truths:
    - "PDF extraction returns structured result with text, quality metrics, and metadata"
    - "DOCX extraction returns structured result with text, quality metrics, and warnings"
    - "Encrypted PDFs throw EncryptedDocumentError with user-friendly message"
    - "Corrupt files throw CorruptDocumentError with user-friendly message"
    - "Documents with <100 chars return requiresOcr: true"
  artifacts:
    - path: "lib/document-extraction/types.ts"
      provides: "ExtractionResult, QualityMetrics, ExtractionWarning types"
      exports: ["ExtractionResult", "QualityMetrics", "ExtractionWarning", "DocumentMetadata"]
    - path: "lib/document-extraction/pdf-extractor.ts"
      provides: "PDF extraction with error handling"
      exports: ["extractPdf"]
    - path: "lib/document-extraction/docx-extractor.ts"
      provides: "DOCX extraction with warnings"
      exports: ["extractDocx"]
    - path: "lib/document-extraction/validators.ts"
      provides: "Quality validation and language detection"
      exports: ["validateExtractionQuality", "detectLanguage"]
    - path: "lib/errors.ts"
      provides: "Document extraction error classes"
      contains: ["EncryptedDocumentError", "CorruptDocumentError", "OcrRequiredError"]
  key_links:
    - from: "lib/document-extraction/pdf-extractor.ts"
      to: "pdf-parse"
      via: "dynamic import"
      pattern: "await import\\('pdf-parse'\\)"
    - from: "lib/document-extraction/index.ts"
      to: "lib/document-extraction/*.ts"
      via: "barrel export"
      pattern: "export.*from"
---

<objective>
Create extraction infrastructure with proper error types, quality metrics, and format-specific extractors.

Purpose: Establish typed foundation for document extraction that differentiates failure modes (encrypted, corrupt, needs-OCR) and provides quality metrics for downstream validation.

Output:
- Document extraction error classes in lib/errors.ts
- Type definitions for extraction results with quality metrics
- PDF extractor with pdf-parse error handling and memory cleanup
- DOCX extractor with mammoth warnings capture
- Quality validators for OCR detection and language check
</objective>

<execution_context>
@/Users/medelman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medelman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-document-extraction/03-RESEARCH.md

# Prior work
@lib/document-processing.ts
@lib/errors.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add document extraction error classes</name>
  <files>lib/errors.ts</files>
  <action>
Add three new error codes and classes to lib/errors.ts:

1. Add to ErrorCode type:
   - "ENCRYPTED_DOCUMENT"
   - "CORRUPT_DOCUMENT"
   - "OCR_REQUIRED"

2. Add EncryptedDocumentError class (400):
   ```typescript
   export class EncryptedDocumentError extends AppError {
     constructor(message = "Please upload an unprotected version of this document.") {
       super("ENCRYPTED_DOCUMENT", message, 400)
     }
   }
   ```

3. Add CorruptDocumentError class (400):
   ```typescript
   export class CorruptDocumentError extends AppError {
     constructor(message = "Could not process this file. Try re-uploading or use a different format.") {
       super("CORRUPT_DOCUMENT", message, 400)
     }
   }
   ```

4. Add OcrRequiredError class (422):
   ```typescript
   export class OcrRequiredError extends AppError {
     constructor(message = "Document requires OCR processing (may take longer)") {
       super("OCR_REQUIRED", message, 422)
     }
   }
   ```

Note: 400 for encrypted/corrupt (user can fix), 422 for OCR (server will process but needs different pipeline).
  </action>
  <verify>TypeScript compiles: `pnpm tsc --noEmit 2>&1 | head -20`</verify>
  <done>Three new error classes exist with appropriate status codes</done>
</task>

<task type="auto">
  <name>Task 2: Create extraction types and quality validators</name>
  <files>lib/document-extraction/types.ts, lib/document-extraction/validators.ts</files>
  <action>
Create lib/document-extraction/ directory and files:

**types.ts:**
```typescript
/**
 * @fileoverview Document extraction type definitions
 * @module lib/document-extraction/types
 */

export interface ExtractionWarning {
  type: 'ocr_required' | 'docx_warning' | 'embedded_images' | 'low_confidence' | 'non_english'
  message: string
}

export interface QualityMetrics {
  /** Total character count after normalization */
  charCount: number
  /** Estimated word count */
  wordCount: number
  /** Number of pages (PDF only, 1 for DOCX) */
  pageCount: number
  /** Extraction confidence 0-1 based on text density */
  confidence: number
  /** Warnings from extraction process */
  warnings: ExtractionWarning[]
  /** True if document should be routed to OCR */
  requiresOcr: boolean
}

export interface DocumentMetadata {
  title?: string
  author?: string
  creationDate?: string
  modificationDate?: string
}

export interface ExtractionResult {
  /** Extracted text, NFC-normalized UTF-8 */
  text: string
  /** Quality metrics for validation gates */
  quality: QualityMetrics
  /** Page count from source document */
  pageCount: number
  /** Document metadata if available */
  metadata: DocumentMetadata
}
```

**validators.ts:**
```typescript
/**
 * @fileoverview Extraction quality validation utilities
 * @module lib/document-extraction/validators
 */

import type { QualityMetrics, ExtractionWarning } from './types'

const MIN_TEXT_LENGTH = 100  // Per CONTEXT.md decision
const MIN_TEXT_TO_SIZE_RATIO = 0.001  // Very low = likely scanned

/**
 * Validates extraction quality and determines if OCR is needed.
 *
 * Per CONTEXT.md: Documents with <100 chars auto-route to OCR.
 */
export function validateExtractionQuality(
  text: string,
  fileSize: number
): QualityMetrics {
  const charCount = text.length
  const wordCount = text.split(/\s+/).filter(Boolean).length
  const ratio = fileSize > 0 ? charCount / fileSize : 0
  const warnings: ExtractionWarning[] = []

  // Determine if OCR is required
  const requiresOcr = charCount < MIN_TEXT_LENGTH

  if (requiresOcr) {
    warnings.push({
      type: 'ocr_required',
      message: 'Document requires OCR processing (may take longer)',
    })
  } else if (ratio < MIN_TEXT_TO_SIZE_RATIO && fileSize > 100_000) {
    // Large file with very little text - suspicious
    warnings.push({
      type: 'low_confidence',
      message: 'Document has unusually low text density',
    })
  }

  // Confidence based on text density
  // Higher ratio = more confident it's actual text
  const confidence = requiresOcr ? 0 : Math.min(1, ratio * 100)

  return {
    charCount,
    wordCount,
    pageCount: 1, // Caller should override for PDFs
    confidence,
    warnings,
    requiresOcr,
  }
}

/**
 * Simple language detection heuristic.
 *
 * Per CONTEXT.md: Block non-English documents with clear message.
 * Uses character script detection as first pass.
 */
export function detectLanguage(text: string): { isEnglish: boolean; confidence: number } {
  // Sample first 5000 chars for efficiency
  const sample = text.slice(0, 5000)

  // Count Latin alphabet characters (a-z, A-Z)
  const latinChars = (sample.match(/[a-zA-Z]/g) || []).length

  // Count non-ASCII characters (CJK, Cyrillic, Arabic, etc.)
  const nonAsciiChars = (sample.match(/[^\x00-\x7F]/g) || []).length

  // English documents should be mostly Latin alphabet
  const latinRatio = latinChars / (latinChars + nonAsciiChars + 1)

  // High confidence if >80% Latin, low if <50%
  const isEnglish = latinRatio > 0.5
  const confidence = latinRatio

  return { isEnglish, confidence }
}
```
  </action>
  <verify>
TypeScript compiles: `pnpm tsc --noEmit 2>&1 | head -20`
Directory exists: `ls -la lib/document-extraction/`
  </verify>
  <done>Types and validators created with OCR detection and language heuristic</done>
</task>

<task type="auto">
  <name>Task 3: Create PDF and DOCX extractors with barrel export</name>
  <files>lib/document-extraction/pdf-extractor.ts, lib/document-extraction/docx-extractor.ts, lib/document-extraction/index.ts</files>
  <action>
**pdf-extractor.ts:**
```typescript
/**
 * @fileoverview PDF text extraction with error handling
 * @module lib/document-extraction/pdf-extractor
 */

import { EncryptedDocumentError, CorruptDocumentError } from '@/lib/errors'
import type { ExtractionResult, ExtractionWarning } from './types'
import { validateExtractionQuality } from './validators'

/**
 * Extracts text from PDF buffer with proper error handling.
 *
 * Uses dynamic import for pdf-parse per CLAUDE.md decision [02-01]
 * to avoid barrel export issues with pdfjs-dist browser dependencies.
 *
 * @throws EncryptedDocumentError - Password-protected PDF
 * @throws CorruptDocumentError - Invalid or corrupt PDF
 */
export async function extractPdf(
  buffer: Buffer,
  fileSize?: number
): Promise<ExtractionResult> {
  // Dynamic import to avoid barrel export issues
  const { PDFParse, PasswordException, InvalidPDFException } = await import('pdf-parse')

  const parser = new PDFParse({ data: buffer })

  try {
    const result = await parser.getText()

    // NFC normalize per CONTEXT.md
    const text = result.text.normalize('NFC')

    // Validate quality with file size
    const quality = validateExtractionQuality(text, fileSize ?? buffer.length)
    quality.pageCount = result.numpages ?? result.pages?.length ?? 1

    // Extract metadata
    const metadata = {
      title: result.info?.Title,
      author: result.info?.Author,
      creationDate: result.info?.CreationDate,
      modificationDate: result.info?.ModDate,
    }

    return {
      text,
      quality,
      pageCount: quality.pageCount,
      metadata,
    }
  } catch (error) {
    if (error instanceof PasswordException) {
      throw new EncryptedDocumentError()
    }
    if (error instanceof InvalidPDFException) {
      throw new CorruptDocumentError()
    }
    // Re-throw unknown errors
    throw error
  } finally {
    // Critical: free memory per RESEARCH.md
    await parser.destroy()
  }
}
```

**docx-extractor.ts:**
```typescript
/**
 * @fileoverview DOCX text extraction with warnings capture
 * @module lib/document-extraction/docx-extractor
 */

import mammoth from 'mammoth'
import { CorruptDocumentError } from '@/lib/errors'
import type { ExtractionResult, ExtractionWarning } from './types'
import { validateExtractionQuality } from './validators'

/**
 * Extracts text from DOCX buffer with warning capture.
 *
 * mammoth.extractRawText() returns accepted changes (final text),
 * per CONTEXT.md decision "Accept all track changes when extracting DOCX."
 *
 * @throws CorruptDocumentError - Invalid or corrupt DOCX
 */
export async function extractDocx(
  buffer: Buffer,
  fileSize?: number
): Promise<ExtractionResult> {
  try {
    const result = await mammoth.extractRawText({ buffer })

    // NFC normalize per CONTEXT.md
    const text = result.value.normalize('NFC')

    // Validate quality with file size
    const quality = validateExtractionQuality(text, fileSize ?? buffer.length)

    // Capture mammoth warnings (embedded objects, images, etc.)
    const docxWarnings: ExtractionWarning[] = result.messages
      .filter(m => m.type === 'warning')
      .map(m => ({
        type: 'docx_warning' as const,
        message: m.message,
      }))

    // Check for embedded images that may contain text
    const hasImages = docxWarnings.some(w =>
      w.message.includes('image') || w.message.includes('picture')
    )

    if (hasImages) {
      docxWarnings.push({
        type: 'embedded_images',
        message: 'Document contains images that may have text',
      })
      // Lower confidence if images present
      quality.confidence = Math.min(quality.confidence, 0.8)
    }

    quality.warnings.push(...docxWarnings)

    return {
      text,
      quality,
      pageCount: 1, // DOCX doesn't have intrinsic pages
      metadata: {}, // mammoth doesn't extract metadata
    }
  } catch (error) {
    throw new CorruptDocumentError(
      'Could not process this Word document. Try re-uploading or use a different format.'
    )
  }
}
```

**index.ts (barrel export):**
```typescript
/**
 * @fileoverview Document extraction module
 *
 * Lightweight barrel export safe for bundling.
 * Heavy dependencies (pdf-parse) use dynamic import in extractors.
 *
 * @module lib/document-extraction
 */

// Types
export type {
  ExtractionResult,
  QualityMetrics,
  ExtractionWarning,
  DocumentMetadata,
} from './types'

// Extractors
export { extractPdf } from './pdf-extractor'
export { extractDocx } from './docx-extractor'

// Validators
export { validateExtractionQuality, detectLanguage } from './validators'
```
  </action>
  <verify>
TypeScript compiles: `pnpm tsc --noEmit 2>&1 | head -20`
Exports check: `grep -E "^export" lib/document-extraction/index.ts`
  </verify>
  <done>PDF and DOCX extractors with error handling, quality metrics, and barrel export</done>
</task>

</tasks>

<verification>
1. All TypeScript compiles without errors
2. `lib/document-extraction/` directory contains 5 files
3. Error classes exist in lib/errors.ts with correct status codes
4. Extractors use dynamic import for pdf-parse
5. Quality metrics include requiresOcr flag
</verification>

<success_criteria>
- Three new error classes (Encrypted, Corrupt, OcrRequired) in lib/errors.ts
- ExtractionResult type with QualityMetrics including requiresOcr flag
- extractPdf catches PasswordException and InvalidPDFException
- extractDocx captures mammoth warnings
- All text normalized with NFC
- Barrel export is lightweight (no heavy deps at import time)
</success_criteria>

<output>
After completion, create `.planning/phases/03-document-extraction/03-01-SUMMARY.md`
</output>
