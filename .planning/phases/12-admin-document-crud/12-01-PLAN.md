---
phase: 12-admin-document-crud
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/(main)/(admin)/admin/actions.ts
  - app/(main)/(admin)/admin/actions.test.ts
  - app/(main)/(admin)/admin/layout.tsx
autonomous: true

must_haves:
  truths:
    - "Admin server actions enforce requireRole(['admin', 'owner']) on every call"
    - "Admin can list all org documents with search, filter, sort, and pagination"
    - "Admin can hard-delete a document with cascade (comparisons cleaned up first, blob deleted)"
    - "Admin can bulk-delete multiple documents"
    - "Admin can update document title"
    - "Admin can delete individual analyses"
    - "Admin can re-trigger analysis on a document"
    - "Admin layout blocks non-admin users via server-side redirect"
  artifacts:
    - path: "app/(main)/(admin)/admin/actions.ts"
      provides: "Admin CRUD server actions"
      exports: ["adminGetDocuments", "adminGetDocumentDetail", "adminUpdateDocumentTitle", "adminDeleteDocument", "adminBulkDeleteDocuments", "adminDeleteAnalysis", "adminTriggerAnalysis"]
    - path: "app/(main)/(admin)/admin/actions.test.ts"
      provides: "Tests for admin actions"
      contains: "adminGetDocuments"
    - path: "app/(main)/(admin)/admin/layout.tsx"
      provides: "Admin layout with role gate"
      contains: "requireRole"
  key_links:
    - from: "app/(main)/(admin)/admin/actions.ts"
      to: "lib/dal.ts"
      via: "requireRole import"
      pattern: "requireRole\\(\\[.admin., .owner.\\]\\)"
    - from: "app/(main)/(admin)/admin/actions.ts"
      to: "db/schema/comparisons.ts"
      via: "comparison cleanup before document delete"
      pattern: "comparisons"
---

<objective>
Create admin server actions for document CRUD and the admin layout with role gating.

Purpose: This is the data layer foundation for the admin page. All admin operations use `requireRole(["admin", "owner"])` instead of `withTenant()`, see ALL org documents (not filtered by uploadedBy), and support hard-delete with cascade cleanup.

Output: Admin server actions file, test file, and admin layout with role gate. Also installs @tanstack/react-table dependency for subsequent plans.
</objective>

<execution_context>
@/Users/medelman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medelman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-admin-document-crud/12-CONTEXT.md
@.planning/phases/12-admin-document-crud/12-RESEARCH.md

@app/(main)/(dashboard)/documents/actions.ts
@app/(main)/(dashboard)/analyses/actions.ts
@app/(main)/(admin)/audit/actions.ts
@lib/dal.ts
@lib/api-response.ts
@db/schema/documents.ts
@db/schema/comparisons.ts
@db/schema/analyses.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install TanStack Table and create admin server actions</name>
  <files>
    app/(main)/(admin)/admin/actions.ts
    package.json
  </files>
  <action>
Install @tanstack/react-table:
```bash
pnpm add @tanstack/react-table
```

Create `app/(main)/(admin)/admin/actions.ts` with "use server" directive. All actions use `requireRole(["admin", "owner"])` per CONTEXT.md locked decision. Import patterns follow `app/(main)/(admin)/audit/actions.ts` as the established admin action pattern.

**Actions to implement:**

1. **adminGetDocuments** - Paginated document listing with search, filter, sort.
   - Input: `{ page: number, pageSize: number, search?: string, status?: string, fileType?: string, dateRange?: string, sortBy?: string, sortOrder?: "asc" | "desc" }`
   - Uses `requireRole(["admin", "owner"])` to get `db` and `tenantId`
   - Builds dynamic where conditions: tenantId match, isNull(deletedAt), plus optional ilike(title, search), eq(status), eq(fileType), date range filter
   - Date range filter: use preset ranges -- "7d" = last 7 days, "30d" = last 30 days, "90d" = last 90 days, "all" = no filter. Compute date threshold with `new Date(Date.now() - days * 86400000)` and use `gte(documents.createdAt, threshold)`
   - Sort: map sortBy to column (title, status, fileType, createdAt, fileSize), default createdAt desc
   - Run parallel queries: paginated data query + count(*) query (same conditions)
   - Return `ApiResponse<{ documents: Document[], total: number }>`
   - Do NOT filter by `uploadedBy` -- admin sees ALL org documents per locked decision

2. **adminGetDocumentDetail** - Get single document with associated analyses.
   - Input: `{ documentId: string }`
   - Fetch document by id + tenantId (include soft-deleted check: `isNull(deletedAt)`)
   - Fetch associated analyses: `db.query.analyses.findMany({ where: and(eq(analyses.documentId, documentId), eq(analyses.tenantId, tenantId)), orderBy: [desc(analyses.version)] })`
   - Return `ApiResponse<{ document: Document, analyses: Analysis[] }>`

3. **adminUpdateDocumentTitle** - Update document title (only `title` is safely editable per RESEARCH.md).
   - Input: `{ documentId: string, title: string }` with zod validation (min 1, max 255, trimmed)
   - Update via `db.update(documents).set({ title, updatedAt: new Date() }).where(...)`
   - `revalidatePath("/admin")`
   - Return updated document

4. **adminDeleteDocument** - Hard delete single document with cascade cleanup.
   - Input: `{ documentId: string }`
   - Steps in order:
     a. Fetch document (id, fileUrl, title) to confirm it exists in tenant
     b. Delete comparisons referencing this document: `db.delete(comparisons).where(and(eq(comparisons.tenantId, tenantId), or(eq(comparisons.documentAId, docId), eq(comparisons.documentBId, docId))))`
     c. Delete blob file: `try { await deleteFile(doc.fileUrl) } catch { /* file may not exist */ }`
     d. Hard delete document: `db.delete(documents).where(eq(documents.id, docId))` -- this cascades to chunks, analyses, classifications via FK onDelete cascade
   - Import `deleteFile` from `@/lib/blob`
   - Import `comparisons` from `@/db/schema`
   - Import `or` from `drizzle-orm`
   - `revalidatePath("/admin")`
   - Return `ApiResponse<{ message: string }>`

5. **adminBulkDeleteDocuments** - Bulk delete multiple documents.
   - Input: `{ documentIds: string[] }` with zod validation (array of uuid, min 1, max 100)
   - Loop through documentIds, calling the same cascade delete logic as adminDeleteDocument for each
   - Collect errors per document, continue on failure
   - `revalidatePath("/admin")`
   - Return `ApiResponse<{ deleted: number, errors: string[] }>`

6. **adminDeleteAnalysis** - Delete individual analysis from a document.
   - Input: `{ analysisId: string }`
   - Verify analysis exists and belongs to tenant
   - Unlike the dashboard version, do NOT block deleting the last analysis (admin can delete any analysis per locked decision "Admin can delete individual analyses from a document")
   - Hard delete: `db.delete(analyses).where(eq(analyses.id, analysisId))`
   - `revalidatePath("/admin")`
   - Return `ApiResponse<void>`

7. **adminTriggerAnalysis** - Re-trigger analysis on existing document.
   - Input: `{ documentId: string }`
   - Verify document exists, belongs to tenant, and has status "ready"
   - Get next version number (max existing version + 1)
   - Create new analysis record with status "pending"
   - Send inngest event: `inngest.send({ name: "nda/analysis.requested", data: { tenantId, documentId, analysisId, source: "admin-retrigger" } })`
   - Import `inngest` from `@/inngest` (barrel is safe for client per CLAUDE.md)
   - `revalidatePath("/admin")`
   - Return `ApiResponse<Analysis>`

Use `wrapError()` for catch blocks (matching audit/actions.ts pattern). All zod schemas defined locally in the file.
  </action>
  <verify>
TypeScript compiles: `cd /Users/medelman/GitHub/medelman17/vibedocs && npx tsc --noEmit --pretty 2>&1 | head -50`
  </verify>
  <done>
All 7 admin server actions exist in actions.ts with requireRole enforcement, hard delete with comparison cleanup, and blob deletion. @tanstack/react-table is installed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Admin layout and action tests</name>
  <files>
    app/(main)/(admin)/admin/layout.tsx
    app/(main)/(admin)/admin/actions.test.ts
  </files>
  <action>
**Admin layout** (`app/(main)/(admin)/admin/layout.tsx`):

Create a server component layout that enforces role gating:

```typescript
import { requireRole } from "@/lib/dal"

export default async function AdminLayout({
  children,
}: {
  children: React.ReactNode
}) {
  await requireRole(["admin", "owner"])

  return (
    <div className="flex h-full flex-col">
      <main className="flex-1 overflow-auto">
        {children}
      </main>
    </div>
  )
}
```

This ensures every route under `/admin/` is server-side role-gated. Non-admin users get redirected to `/dashboard?error=unauthorized` by `requireRole()`.

**Action tests** (`app/(main)/(admin)/admin/actions.test.ts`):

Write Vitest tests following the project's PGlite testing pattern (see `test/setup.ts`). Test the core admin action logic:

1. Test `adminGetDocuments` returns paginated results with total count
2. Test `adminGetDocuments` with search filter returns matching documents
3. Test `adminGetDocuments` with status filter
4. Test `adminUpdateDocumentTitle` updates title successfully
5. Test `adminDeleteDocument` cascade logic (verify comparisons cleaned up, document hard-deleted)
6. Test `adminBulkDeleteDocuments` handles partial failures gracefully
7. Test `adminDeleteAnalysis` allows deleting the last analysis (unlike dashboard)

Mock `requireRole` to return a test context with db and tenantId. Mock `deleteFile` from `@/lib/blob` to avoid real blob operations. Mock `inngest.send` for trigger analysis test.

Use `vi.mock()` for the DAL and blob modules. Use `vi.resetModules()` in beforeEach for clean state.
  </action>
  <verify>
Tests pass: `cd /Users/medelman/GitHub/medelman17/vibedocs && pnpm test -- app/\(main\)/\(admin\)/admin/actions.test.ts --run 2>&1 | tail -30`
  </verify>
  <done>
Admin layout enforces requireRole server-side. Action tests verify pagination, search, filter, hard-delete cascade, bulk delete, and analysis deletion without last-analysis guard.
  </done>
</task>

</tasks>

<verification>
1. `pnpm test -- app/(main)/(admin)/admin/actions.test.ts --run` passes
2. `npx tsc --noEmit` shows no type errors in admin files
3. `@tanstack/react-table` appears in package.json dependencies
</verification>

<success_criteria>
- All 7 admin server actions exist with requireRole enforcement
- Hard delete properly cleans up comparisons before deleting document
- Blob file deleted before DB row (per research pitfall 6)
- Admin layout server-side redirects non-admin users
- Tests pass for core action logic
- @tanstack/react-table installed
</success_criteria>

<output>
After completion, create `.planning/phases/12-admin-document-crud/12-01-SUMMARY.md`
</output>
