---
phase: 04-ocr-processing
plan: 03
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - db/schema/analyses.ts
  - inngest/functions/ocr-document.ts
  - inngest/functions/index.ts
  - inngest/types.ts
autonomous: true

must_haves:
  truths:
    - "Documents with pending_ocr status trigger OCR processing"
    - "OCR results are persisted to analyses table"
    - "OCR completion triggers analysis pipeline continuation"
  artifacts:
    - path: "inngest/functions/ocr-document.ts"
      provides: "Inngest OCR processing function"
      exports: ["ocrDocument"]
    - path: "db/schema/analyses.ts"
      provides: "OCR fields on analyses table"
      contains: ["ocrText", "ocrConfidence", "ocrWarning"]
  key_links:
    - from: "inngest/functions/ocr-document.ts"
      to: "lib/ocr/ocr-processor.ts"
      via: "ocrPdf"
      pattern: "ocrPdf"
    - from: "inngest/functions/ocr-document.ts"
      to: "nda/analysis.ocr-complete"
      via: "step.sendEvent"
      pattern: "nda/analysis\\.ocr-complete"
---

<objective>
Integrate OCR processing into the Inngest pipeline with database persistence.

Purpose: Wire OCR into the analysis pipeline - when a document is detected as requiring OCR (pending_ocr status), the OCR Inngest function processes it, persists results, and triggers continuation of the main analysis pipeline.

Output: Working OCR pipeline integration with durable Inngest steps and database persistence.
</objective>

<execution_context>
@/Users/medelman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medelman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-ocr-processing/04-RESEARCH.md
@.planning/phases/04-ocr-processing/04-02-SUMMARY.md

# Existing pipeline patterns
@inngest/functions/analyze-nda.ts
@inngest/types.ts
@db/schema/analyses.ts

# OCR utilities from Plan 02
@lib/ocr/ocr-processor.ts
@lib/ocr/quality.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add OCR fields to analyses schema</name>
  <files>db/schema/analyses.ts</files>
  <action>
Add OCR-specific fields to the analyses table. Add these fields AFTER the existing `metadata` field and BEFORE `completedAt`:

```typescript
// Add to analyses table definition in db/schema/analyses.ts

    // OCR Processing Fields (for scanned documents)
    // ==============================================

    /**
     * OCR-extracted text (if document required OCR processing).
     *
     * Populated by the ocr-document Inngest function when a scanned
     * PDF is detected. Null for documents that extracted text normally.
     *
     * @see {@link lib/ocr/ocr-processor.ts|OCR Processor}
     */
    ocrText: text("ocr_text"),

    /**
     * Average OCR confidence score (0-100).
     *
     * Tesseract provides per-page confidence; this is the average.
     * - >= 85: Good quality, no warning
     * - 60-84: Low quality, show warning
     * - < 60: Critical quality, may be unusable
     */
    ocrConfidence: real("ocr_confidence"),

    /**
     * User-facing warning message about OCR quality.
     *
     * Null if OCR quality is acceptable (>= 85% confidence).
     * Displayed in UI to inform user about potential accuracy issues.
     */
    ocrWarning: text("ocr_warning"),

    /**
     * Timestamp when OCR processing completed.
     *
     * Tracks OCR-specific timing separately from overall completion.
     */
    ocrCompletedAt: timestamp("ocr_completed_at", { withTimezone: true }),
```

Also add 'pending_ocr' to the status documentation comment (around line 70):

```typescript
/**
 * Analysis processing status values.
 *
 * @typedef {'pending' | 'pending_ocr' | 'processing' | 'completed' | 'failed'} AnalysisStatus
 *
 * Status progression:
 * - **pending**: Analysis queued, awaiting processing
 * - **pending_ocr**: Document requires OCR before analysis can proceed
 * - **processing**: Inngest workflow actively running agents
 * - **completed**: All agents finished successfully
 * - **failed**: Pipeline encountered unrecoverable error
 */
```

NOTE: The 'pending_ocr' status is already being set by analyze-nda.ts (from Phase 3), we're just documenting it properly.
  </action>
  <verify>`pnpm db:generate` succeeds (generates migration for new columns)</verify>
  <done>OCR fields added to analyses schema with proper documentation</done>
</task>

<task type="auto">
  <name>Task 2: Add OCR event types to Inngest</name>
  <files>inngest/types.ts</files>
  <action>
Add OCR-related event types to the Inngest types file. Add these to the existing event type definitions:

```typescript
// Add to InngestEvents interface in inngest/types.ts

  // OCR Events
  // ==========

  /**
   * Request OCR processing for a scanned document.
   * Triggered when extraction detects a document requires OCR.
   */
  'nda/ocr.requested': {
    data: {
      documentId: string
      analysisId: string
      tenantId: string
    }
  }

  /**
   * OCR processing completed.
   * Triggers continuation of the analysis pipeline.
   */
  'nda/analysis.ocr-complete': {
    data: {
      documentId: string
      analysisId: string
      tenantId: string
      /** OCR-extracted text */
      ocrText: string
      /** OCR quality assessment */
      quality: {
        confidence: number
        isLowQuality: boolean
        warningMessage?: string
        affectedPages: number[]
      }
    }
  }
```

These events enable:
1. `nda/ocr.requested` - Trigger OCR function when document needs OCR
2. `nda/analysis.ocr-complete` - Resume main pipeline after OCR finishes
  </action>
  <verify>TypeScript compiles: `pnpm exec tsc --noEmit inngest/types.ts`</verify>
  <done>OCR event types defined in Inngest types</done>
</task>

<task type="auto">
  <name>Task 3: Create OCR document Inngest function</name>
  <files>inngest/functions/ocr-document.ts, inngest/functions/index.ts</files>
  <action>
Create the Inngest function for OCR processing following existing patterns from analyze-nda.ts:

```typescript
// inngest/functions/ocr-document.ts
/**
 * @fileoverview OCR Document Processing Function
 *
 * Processes scanned PDFs that require OCR before analysis.
 * Triggered when extraction detects a document with status 'pending_ocr'.
 *
 * @module inngest/functions/ocr-document
 */

import { inngest, CONCURRENCY, withTenantContext } from '@/inngest'
import { NonRetriableError } from '@/inngest/utils/errors'
import { ocrPdf } from '@/lib/ocr/ocr-processor'
import { assessOcrQuality } from '@/lib/ocr/quality'
import { analyses } from '@/db/schema/analyses'
import { documents } from '@/db/schema/documents'
import { eq } from 'drizzle-orm'
import { head } from '@vercel/blob'

/**
 * OCR Document Processing Function
 *
 * Handles scanned PDFs that couldn't be text-extracted normally:
 * 1. Fetches document from blob storage
 * 2. Runs OCR on all pages
 * 3. Persists OCR results to analysis record
 * 4. Triggers continuation of main analysis pipeline
 *
 * Memory considerations:
 * - OCR is memory-intensive (~100MB for large documents)
 * - Pages processed sequentially (not parallel)
 * - Limited retries due to cost (OCR is slow)
 */
export const ocrDocument = inngest.createFunction(
  {
    id: 'ocr-document',
    name: 'OCR Document Processing',
    concurrency: CONCURRENCY.analysis, // Share concurrency with main pipeline
    retries: 2, // Limited retries - OCR is expensive
  },
  { event: 'nda/ocr.requested' },
  async ({ event, step }) => {
    const { documentId, analysisId, tenantId } = event.data
    const startTime = Date.now()

    return await withTenantContext(tenantId, async (ctx) => {
      // Step 1: Fetch document metadata and blob URL
      const document = await step.run('fetch-document-info', async () => {
        const doc = await ctx.db.query.documents.findFirst({
          where: eq(documents.id, documentId),
          columns: {
            id: true,
            blobUrl: true,
            fileName: true,
            mimeType: true,
          },
        })

        if (!doc) {
          throw new NonRetriableError(`Document ${documentId} not found`)
        }

        if (!doc.blobUrl) {
          throw new NonRetriableError('Document has no blob URL')
        }

        return doc
      })

      // Step 2: Download document from blob storage
      const pdfBuffer = await step.run('download-document', async () => {
        const response = await fetch(document.blobUrl!)

        if (!response.ok) {
          throw new NonRetriableError(
            `Failed to download document: ${response.status}`
          )
        }

        const arrayBuffer = await response.arrayBuffer()
        return Buffer.from(arrayBuffer)
      })

      // Step 3: Update status to show OCR in progress
      await step.run('update-status-processing', async () => {
        await ctx.db
          .update(analyses)
          .set({
            progressStage: 'ocr_processing',
            progressPercent: 10,
            updatedAt: new Date(),
          })
          .where(eq(analyses.id, analysisId))
      })

      // Step 4: Run OCR (potentially long-running, 10-30s per page)
      const ocrResult = await step.run('run-ocr', async () => {
        console.log('[OCR] Starting OCR processing', {
          documentId,
          analysisId,
          fileName: document.fileName,
        })

        return await ocrPdf(pdfBuffer)
      })

      // Step 5: Assess quality
      const quality = assessOcrQuality(ocrResult)

      console.log('[OCR] Processing complete', {
        analysisId,
        pages: ocrResult.pages.length,
        averageConfidence: ocrResult.averageConfidence.toFixed(1),
        isLowQuality: quality.isLowQuality,
        processingTimeMs: Date.now() - startTime,
      })

      // Step 6: Persist OCR results
      await step.run('persist-ocr-result', async () => {
        await ctx.db
          .update(analyses)
          .set({
            status: 'processing', // Resume normal pipeline status
            ocrText: ocrResult.text,
            ocrConfidence: ocrResult.averageConfidence,
            ocrWarning: quality.isLowQuality ? quality.warningMessage : null,
            ocrCompletedAt: new Date(),
            progressStage: 'parsing', // Next stage after OCR
            progressPercent: 20,
            metadata: {
              ocrPageCount: ocrResult.pages.length,
              ocrLowConfidencePages: quality.affectedPages,
              ocrProcessingTimeMs: Date.now() - startTime,
            },
          })
          .where(eq(analyses.id, analysisId))
      })

      // Step 7: Trigger continuation of main analysis pipeline
      await step.sendEvent('resume-analysis', {
        name: 'nda/analysis.ocr-complete',
        data: {
          documentId,
          analysisId,
          tenantId,
          ocrText: ocrResult.text,
          quality: {
            confidence: quality.confidence,
            isLowQuality: quality.isLowQuality,
            warningMessage: quality.warningMessage,
            affectedPages: quality.affectedPages,
          },
        },
      })

      return {
        success: true,
        analysisId,
        pages: ocrResult.pages.length,
        confidence: ocrResult.averageConfidence,
        isLowQuality: quality.isLowQuality,
      }
    })
  }
)
```

Update the functions barrel export to include the new function:

```typescript
// inngest/functions/index.ts
// Add to existing exports:

export { ocrDocument } from './ocr-document'
```

NOTE: The functions barrel export is safe per CLAUDE.md because it doesn't pull in heavy deps directly - each function uses dynamic imports for heavy libraries.
  </action>
  <verify>TypeScript compiles: `pnpm exec tsc --noEmit inngest/functions/ocr-document.ts`</verify>
  <done>OCR Inngest function processes scanned PDFs and triggers pipeline continuation</done>
</task>

</tasks>

<verification>
1. Schema generates: `pnpm db:generate`
2. Types compile: `pnpm exec tsc --noEmit inngest/types.ts`
3. Function compiles: `pnpm exec tsc --noEmit inngest/functions/ocr-document.ts`
4. All tests pass: `pnpm test`
5. Lint passes: `pnpm lint`
</verification>

<success_criteria>
- OCR fields added to analyses table (ocrText, ocrConfidence, ocrWarning, ocrCompletedAt)
- pending_ocr status documented in schema
- OCR event types defined (nda/ocr.requested, nda/analysis.ocr-complete)
- Inngest function handles OCR processing with durable steps
- OCR completion triggers pipeline continuation event
</success_criteria>

<output>
After completion, create `.planning/phases/04-ocr-processing/04-03-SUMMARY.md`
</output>
