---
phase: 04-ocr-processing
plan: 04
type: execute
wave: 4
depends_on: ["04-03"]
files_modified:
  - components/analysis/ocr-warning.tsx
  - inngest/functions/analyze-nda.ts
autonomous: true

must_haves:
  truths:
    - "User sees warning when viewing analysis with low OCR quality"
    - "OCR-triggered analyses use OCR text instead of re-extracting"
    - "Warning is actionable (suggests uploading clearer scan)"
  artifacts:
    - path: "components/analysis/ocr-warning.tsx"
      provides: "OCR quality warning UI component"
      exports: ["OcrWarning"]
    - path: "inngest/functions/analyze-nda.ts"
      provides: "Pipeline handles OCR completion event"
      contains: ["nda/analysis.ocr-complete"]
  key_links:
    - from: "components/analysis/ocr-warning.tsx"
      to: "analyses.ocrWarning"
      via: "prop from analysis record"
      pattern: "ocrWarning"
---

<objective>
Create UI warning component and wire OCR completion into the main analysis pipeline.

Purpose: Complete the user experience - users see clear warnings about OCR quality issues, and the analysis pipeline correctly handles documents that went through OCR processing.

Output: Working end-to-end OCR flow with user-visible quality warnings.
</objective>

<execution_context>
@/Users/medelman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medelman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-ocr-processing/04-RESEARCH.md
@.planning/phases/04-ocr-processing/04-03-SUMMARY.md

# Existing UI patterns
@components/ui/alert.tsx

# Pipeline to update
@inngest/functions/analyze-nda.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create OCR warning UI component</name>
  <files>components/analysis/ocr-warning.tsx</files>
  <action>
Create a reusable OCR warning component following existing shadcn/ui patterns:

```typescript
// components/analysis/ocr-warning.tsx
/**
 * @fileoverview OCR Quality Warning Component
 *
 * Displays warnings about OCR quality to inform users when
 * analysis accuracy may be affected by scanned document quality.
 *
 * @module components/analysis/ocr-warning
 */

'use client'

import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert'
import { AlertTriangle, FileWarning } from 'lucide-react'
import { CONFIDENCE_THRESHOLD, CRITICAL_THRESHOLD } from '@/lib/ocr/types'

interface OcrWarningProps {
  /** Average OCR confidence (0-100) */
  confidence: number
  /** Warning message from OCR processing */
  warningMessage?: string | null
  /** Optional className for styling */
  className?: string
}

/**
 * Display OCR quality warning when confidence is below threshold.
 *
 * Shows nothing if confidence is good (>= 85%).
 * Shows warning for low quality (60-84%).
 * Shows critical warning for very low quality (< 60%).
 *
 * @example
 * ```tsx
 * <OcrWarning
 *   confidence={analysis.ocrConfidence}
 *   warningMessage={analysis.ocrWarning}
 * />
 * ```
 */
export function OcrWarning({
  confidence,
  warningMessage,
  className,
}: OcrWarningProps) {
  // No warning needed for good quality
  if (confidence >= CONFIDENCE_THRESHOLD) {
    return null
  }

  const isCritical = confidence < CRITICAL_THRESHOLD
  const Icon = isCritical ? FileWarning : AlertTriangle

  return (
    <Alert
      variant={isCritical ? 'destructive' : 'default'}
      className={className}
      data-slot="ocr-warning"
    >
      <Icon className="h-4 w-4" />
      <AlertTitle>
        {isCritical ? 'Document Quality Issue' : 'OCR Quality Notice'}
      </AlertTitle>
      <AlertDescription>
        {warningMessage || (isCritical
          ? 'This document has very low OCR quality. Analysis results may be significantly inaccurate. Consider uploading a clearer scan or the original document if available.'
          : 'Some parts of this document were difficult to read. Analysis accuracy may be affected.'
        )}
      </AlertDescription>
    </Alert>
  )
}

/**
 * Check if an analysis has OCR quality issues that should be displayed.
 *
 * Utility function for conditional rendering.
 *
 * @example
 * ```tsx
 * {hasOcrIssues(analysis) && (
 *   <OcrWarning
 *     confidence={analysis.ocrConfidence!}
 *     warningMessage={analysis.ocrWarning}
 *   />
 * )}
 * ```
 */
export function hasOcrIssues(analysis: {
  ocrConfidence?: number | null
  ocrWarning?: string | null
}): boolean {
  if (analysis.ocrConfidence == null) {
    return false
  }
  return analysis.ocrConfidence < CONFIDENCE_THRESHOLD || !!analysis.ocrWarning
}
```

This component:
- Uses existing Alert from shadcn/ui
- Shows nothing for good quality (clean experience)
- Shows warning variant for low quality
- Shows destructive variant for critical quality
- Includes utility function for conditional rendering
- Uses data-slot for styling hooks per project convention
  </action>
  <verify>TypeScript compiles and lint passes: `pnpm exec tsc --noEmit components/analysis/ocr-warning.tsx && pnpm lint`</verify>
  <done>OCR warning component renders appropriate warning based on confidence level</done>
</task>

<task type="auto">
  <name>Task 2: Handle OCR completion in main pipeline</name>
  <files>inngest/functions/analyze-nda.ts</files>
  <action>
Update analyze-nda.ts to handle the `nda/analysis.ocr-complete` event. Add a second event trigger that accepts OCR-completed documents.

First, add a new function to handle OCR completion (add AFTER the existing analyzeNda function):

```typescript
// Add to inngest/functions/analyze-nda.ts

/**
 * Continue analysis pipeline after OCR processing completes.
 *
 * This function handles documents that went through OCR and continues
 * from the parser stage using the OCR-extracted text.
 */
export const analyzeNdaAfterOcr = inngest.createFunction(
  {
    id: 'analyze-nda-after-ocr',
    name: 'NDA Analysis Pipeline (Post-OCR)',
    concurrency: CONCURRENCY.analysis,
    retries: RETRY_CONFIG.default.retries,
  },
  { event: 'nda/analysis.ocr-complete' },
  async ({ event, step }) => {
    const { documentId, analysisId, tenantId, ocrText, quality } = event.data

    const budgetTracker = new BudgetTracker()
    const startTime = Date.now()

    return await withTenantContext(tenantId, async (ctx) => {
      // Helper to emit progress events AND persist to DB
      const emitProgress = async (
        stage: ProgressStage,
        progress: number,
        message: string
      ) => {
        const clampedProgress = Math.max(0, Math.min(100, progress))

        await step.run(`update-progress-${stage}`, async () => {
          await ctx.db
            .update(analyses)
            .set({
              progressStage: stage,
              progressPercent: clampedProgress,
              updatedAt: new Date(),
            })
            .where(eq(analyses.id, analysisId))
        })

        await step.sendEvent(`emit-progress-${stage}`, {
          name: 'nda/analysis.progress',
          data: {
            documentId,
            analysisId,
            tenantId,
            stage,
            progress: clampedProgress,
            message,
          },
        })
      }

      // Step 1: Run parser on OCR text
      // NOTE: We use the simpler parsing path since we already have text
      const parserResult = await step.run('parser-agent-ocr', () =>
        runParserAgent({
          documentId,
          tenantId,
          source: 'web', // OCR documents came from web upload
          content: ocrText, // Use OCR text directly
          metadata: {
            wasOcr: true,
            ocrConfidence: quality.confidence,
          },
        })
      )

      // Parser validation gate
      const parserValidation = validateParserOutput(
        parserResult.document.rawText,
        parserResult.document.chunks
      )
      if (!parserValidation.valid) {
        await step.run('mark-parser-failed', async () => {
          await ctx.db
            .update(analyses)
            .set({
              status: 'failed',
              progressStage: 'failed',
              metadata: {
                failedAt: 'parsing',
                errorCode: parserValidation.error!.code,
                errorMessage: parserValidation.error!.userMessage,
                wasOcr: true,
              },
            })
            .where(eq(analyses.id, analysisId))
        })
        throw new NonRetriableError(parserValidation.error!.userMessage)
      }

      // Token budget validation
      const budgetValidation = validateTokenBudget(
        parserResult.document.rawText,
        parserResult.document.chunks.map(c => ({
          id: c.id,
          index: c.index,
          content: c.content,
          tokenCount: c.tokenCount ?? 0,
          sectionPath: c.sectionPath,
          startPosition: c.startPosition,
          endPosition: c.endPosition,
        }))
      )

      let workingDocument = parserResult.document
      let wasTruncated = false

      if (budgetValidation.truncation) {
        workingDocument = {
          ...parserResult.document,
          rawText: budgetValidation.truncation.text,
          chunks: budgetValidation.truncation.chunks.map((c, i) => ({
            ...parserResult.document.chunks.find(orig => orig.id === c.id) ?? parserResult.document.chunks[i],
            content: c.content,
          })),
        }
        wasTruncated = true
      }

      await step.run('record-budget-estimate', async () => {
        await ctx.db
          .update(analyses)
          .set({
            estimatedTokens: budgetValidation.estimate.tokenCount,
            wasTruncated,
          })
          .where(eq(analyses.id, analysisId))
      })

      await emitProgress(
        'parsing',
        25,
        `Parsed ${workingDocument.chunks.length} chunks from OCR text`
      )

      await step.sleep('rate-limit-parser', getRateLimitDelay('claude'))

      // Step 2: Classifier Agent
      const classifierResult = await step.run('classifier-agent', () =>
        runClassifierAgent({
          parsedDocument: workingDocument,
          budgetTracker,
        })
      )

      const classifierValidation = validateClassifierOutput(classifierResult.clauses)
      if (!classifierValidation.valid) {
        await step.run('mark-classifier-failed', async () => {
          await ctx.db
            .update(analyses)
            .set({
              status: 'failed',
              progressStage: 'failed',
              metadata: {
                failedAt: 'classifying',
                errorCode: classifierValidation.error!.code,
                errorMessage: classifierValidation.error!.userMessage,
                wasOcr: true,
              },
            })
            .where(eq(analyses.id, analysisId))
        })
        throw new NonRetriableError(classifierValidation.error!.userMessage)
      }

      await emitProgress(
        'classifying',
        50,
        `Classified ${classifierResult.clauses.length} clauses`
      )

      await step.sleep('rate-limit-classifier', getRateLimitDelay('claude'))

      // Step 3: Risk Scorer Agent
      const riskResult = await step.run('risk-scorer-agent', () =>
        runRiskScorerAgent({
          clauses: classifierResult.clauses,
          budgetTracker,
        })
      )
      await emitProgress(
        'scoring',
        75,
        `Scored ${riskResult.assessments.length} clauses`
      )

      await step.sleep('rate-limit-risk', getRateLimitDelay('claude'))

      // Step 4: Gap Analyst Agent
      const documentSummary = `${parserResult.document.title}: ${classifierResult.clauses.length} clauses identified.`
      const gapResult = await step.run('gap-analyst-agent', () =>
        runGapAnalystAgent({
          clauses: classifierResult.clauses,
          assessments: riskResult.assessments,
          documentSummary,
          budgetTracker,
        })
      )
      await emitProgress('analyzing_gaps', 90, 'Gap analysis complete')

      // Step 5: Persist final results
      await step.run('persist-final', async () => {
        const usage = budgetTracker.getUsage()

        await ctx.db
          .update(analyses)
          .set({
            status: 'completed',
            overallRiskScore: riskResult.overallRiskScore,
            overallRiskLevel: riskResult.overallRiskLevel,
            gapAnalysis: gapResult.gapAnalysis,
            tokenUsage: usage,
            actualTokens: usage.total.total,
            estimatedCost: usage.total.estimatedCost,
            processingTimeMs: Date.now() - startTime,
            completedAt: new Date(),
          })
          .where(eq(analyses.id, analysisId))
      })

      await emitProgress('complete', 100, 'Analysis complete')

      await step.sendEvent('analysis-completed', {
        name: 'nda/analysis.completed',
        data: {
          documentId,
          analysisId,
          tenantId,
          overallRiskScore: riskResult.overallRiskScore,
          overallRiskLevel: riskResult.overallRiskLevel,
          wasOcr: true,
        },
      })

      return { analysisId, success: true, wasOcr: true }
    })
  }
)
```

Also add 'ocr_processing' to the ProgressStage type if not already present. Check inngest/types.ts and add it to AnalysisProgressPayload if needed.
  </action>
  <verify>TypeScript compiles: `pnpm exec tsc --noEmit inngest/functions/analyze-nda.ts`</verify>
  <done>Analysis pipeline continues from OCR completion using OCR text</done>
</task>

<task type="auto">
  <name>Task 3: Export new function and update types</name>
  <files>inngest/functions/index.ts, inngest/types.ts</files>
  <action>
Update exports and types for the new OCR completion handler.

In `inngest/functions/index.ts`, add the new function export:

```typescript
// Add to existing exports
export { analyzeNda, analyzeNdaAfterOcr } from './analyze-nda'
```

In `inngest/types.ts`, ensure 'ocr_processing' is in the ProgressStage type. Find the AnalysisProgressPayload type and update the stage union:

```typescript
// Update AnalysisProgressPayload in inngest/types.ts
export interface AnalysisProgressPayload {
  documentId: string
  analysisId: string
  tenantId: string
  stage: 'parsing' | 'ocr_processing' | 'classifying' | 'scoring' | 'analyzing_gaps' | 'complete' | 'failed'
  progress: number
  message: string
}
```

Make sure both functions are registered with Inngest. Check if there's a serve() call that needs updating (likely in app/api/inngest/route.ts).
  </action>
  <verify>`pnpm exec tsc --noEmit inngest/functions/index.ts && pnpm build`</verify>
  <done>New function exported and progress stages include ocr_processing</done>
</task>

</tasks>

<verification>
1. UI component compiles: `pnpm exec tsc --noEmit components/analysis/ocr-warning.tsx`
2. Pipeline compiles: `pnpm exec tsc --noEmit inngest/functions/analyze-nda.ts`
3. All tests pass: `pnpm test`
4. Build succeeds: `pnpm build`
5. Lint passes: `pnpm lint`
</verification>

<success_criteria>
- OCR warning component displays appropriate warning based on confidence
- Warning component shows nothing for good quality (>= 85%)
- Warning component shows destructive variant for critical quality (< 60%)
- Analysis pipeline handles nda/analysis.ocr-complete event
- Post-OCR pipeline uses OCR text instead of re-extracting
- Progress stages include ocr_processing
</success_criteria>

<output>
After completion, create `.planning/phases/04-ocr-processing/04-04-SUMMARY.md`
</output>
