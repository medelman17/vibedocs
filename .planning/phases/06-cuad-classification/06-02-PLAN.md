---
phase: 06-cuad-classification
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - agents/classifier.ts
  - agents/prompts/classifier.ts
autonomous: true

must_haves:
  truths:
    - "Classifier processes chunks in batches of 3-5 per LLM call"
    - "Each chunk is classified with 1-2 surrounding chunks as context"
    - "Two-stage RAG narrows candidate categories via vector search before LLM classification"
    - "Chunks below 0.3 confidence are labeled Uncategorized"
  artifacts:
    - path: "agents/classifier.ts"
      provides: "Enhanced batch classifier with neighbor context and two-stage RAG"
      exports: ["runClassifierAgent", "ClassifierOutput"]
    - path: "agents/prompts/classifier.ts"
      provides: "Batch classification prompt with neighbor context and candidate categories"
      exports: ["createBatchClassifierPrompt", "CLASSIFIER_SYSTEM_PROMPT"]
  key_links:
    - from: "agents/classifier.ts"
      to: "agents/tools/vector-search.ts"
      via: "findSimilarClauses() for two-stage RAG retrieval"
      pattern: "findSimilarClauses"
    - from: "agents/classifier.ts"
      to: "agents/types.ts"
      via: "multiLabelClassificationSchema for structured output"
      pattern: "multiLabelClassificationSchema"
---

<objective>
Enhance the classifier agent to use batch classification, neighbor chunk context, and two-stage RAG retrieval for improved CUAD classification accuracy.

Purpose: The current classifier processes one chunk at a time with only 3 reference examples and no surrounding context. The enhanced version batches 3-5 chunks per LLM call (reducing API round-trips from ~30 to ~8), includes 1-2 neighbor chunks for boundary-spanning clauses, uses 7 reference examples from both CUAD and ContractNLI, and narrows candidate categories via vector search before classification.

Output: Enhanced `runClassifierAgent()` function and `createBatchClassifierPrompt()` prompt builder
</objective>

<execution_context>
@/Users/medelman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medelman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-cuad-classification/06-CONTEXT.md
@.planning/phases/06-cuad-classification/06-RESEARCH.md
@.planning/phases/06-cuad-classification/06-01-SUMMARY.md
@agents/classifier.ts
@agents/prompts/classifier.ts
@agents/types.ts
@agents/tools/vector-search.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance classifier prompt for batch classification with neighbor context</name>
  <files>agents/prompts/classifier.ts</files>
  <action>
Rewrite `agents/prompts/classifier.ts` to support batch classification with neighbor context and candidate categories.

**Keep the existing `CLASSIFIER_SYSTEM_PROMPT`** but update it:
- Keep the CUAD category listing
- Update classification guidelines to mention batch processing
- Add note about "Uncategorized" for chunks that match no CUAD category
- Keep the confidence scoring scale (0.9-1.0, 0.7-0.9, etc.)
- Update output format to match the batch schema (array of classifications)

**Keep the existing `createClassifierPrompt` function** (needed by current pipeline until Plan 03 rewires it).

**Add a new `createBatchClassifierPrompt` function:**
```typescript
export function createBatchClassifierPrompt(
  chunks: Array<{
    index: number
    content: string
    sectionPath?: string[] | null
    prevContext?: string
    nextContext?: string
  }>,
  references: Array<{ content: string; category: string; similarity: number; source: string }>,
  candidateCategories: string[]
): string
```

The prompt should include:
1. **Candidate categories section**: List the narrowed categories from vector search. Add note: "You may also assign categories NOT in this list if the text clearly belongs elsewhere. Use 'Uncategorized' only if no CUAD category fits at all."
2. **Reference examples section**: Format as numbered list with category, source, similarity percentage, and first 200 chars of content.
3. **Chunks section**: For each chunk, include:
   - Section path (if available) as `[Section: Article 5 > Section 5.2]`
   - Preceding context (if available) as `[PRECEDING CONTEXT]: ...{text}`
   - The chunk content
   - Following context (if available) as `[FOLLOWING CONTEXT]: {text}...`
4. **Instruction**: "Classify each chunk. Return JSON with classifications array."
  </action>
  <verify>Run `pnpm build` and verify the prompt module compiles. Both `createClassifierPrompt` (old) and `createBatchClassifierPrompt` (new) should be exported.</verify>
  <done>`createBatchClassifierPrompt` exported. System prompt updated with Uncategorized guidance. Old `createClassifierPrompt` preserved for backward compatibility.</done>
</task>

<task type="auto">
  <name>Task 2: Rewrite classifier agent for batch classification with two-stage RAG</name>
  <files>agents/classifier.ts</files>
  <action>
Rewrite the `runClassifierAgent` function in `agents/classifier.ts` to implement batch classification with two-stage RAG retrieval and neighbor context.

**Preserve existing exports** (`ParsedChunk`, `ClassifierInput`, `ClassifiedClause`, `ClassifierOutput`) - they're used by the pipeline.

**New internal types (not exported):**
```typescript
/** Neighbor context for a chunk */
interface NeighborContext {
  prev?: string  // Last 200 chars of previous chunk
  next?: string  // First 200 chars of next chunk
}
```

**New helper function: `buildNeighborMap`**
```typescript
function buildNeighborMap(chunks: ParsedChunk[]): Map<string, NeighborContext> {
  const map = new Map<string, NeighborContext>()
  for (let i = 0; i < chunks.length; i++) {
    map.set(chunks[i].id, {
      prev: i > 0 ? chunks[i - 1].content.slice(-200) : undefined,
      next: i < chunks.length - 1 ? chunks[i + 1].content.slice(0, 200) : undefined,
    })
  }
  return map
}
```

**Rewrite `runClassifierAgent`:**

1. Build neighbor map from chunks
2. Process chunks in batches of 4 (3-5 range, 4 is a good default)
3. For each batch:
   a. **Two-stage RAG**: For each chunk in batch, call `findSimilarClauses(chunk.content, { limit: 7 })`. Collect ALL references across the batch, deduplicate by ID, take top 10 by similarity.
   b. **Extract candidate categories**: Get unique categories from all references.
   c. **Build batch prompt**: Use `createBatchClassifierPrompt` with chunk content, neighbor context from map, section paths, references, and candidate categories.
   d. **Call LLM**: Use `generateText` with `Output.object({ schema: multiLabelClassificationSchema })`.
   e. **Process results**: For each classification in the batch output:
     - If primary confidence < 0.3, set category to "Uncategorized" and confidence to the original confidence
     - Filter secondary classifications below 0.3 confidence
     - Map back to `ClassifiedClause` format for compatibility
4. Track token usage across all batches

**Error handling:**
- Wrap `generateText` call in try/catch for `NoObjectGeneratedError`
- Log batch number and chunk indices on failure
- On batch failure, throw `AnalysisFailedError` with batch context

**Important: The function still returns `ClassifierOutput` (with `clauses: ClassifiedClause[]`)** for backward compatibility with the pipeline. Plan 03 will add the separate persistence to `chunkClassifications`.

The mapping from batch output to `ClassifiedClause[]`:
```typescript
// For each classification result in batch
clauses.push({
  chunkId: chunk.id,
  clauseText: chunk.content,
  category: result.primary.category as CuadCategory,  // "Uncategorized" won't match CuadCategory but that's fine for now
  secondaryCategories: result.secondary.map(s => s.category),
  confidence: result.primary.confidence,
  reasoning: result.primary.rationale,
  startPosition: chunk.startPosition,
  endPosition: chunk.endPosition,
})
```

Note: Skip chunks where the primary category is "Uncategorized" from the `clauses` array output (same behavior as current Unknown filter), BUT store the raw results so Plan 03 can persist ALL classifications including Uncategorized to the new table.

**Add a new exported property to `ClassifierOutput`:**
```typescript
export interface ClassifierOutput {
  clauses: ClassifiedClause[]                    // Filtered (no Uncategorized) for risk-scorer compat
  rawClassifications: ChunkClassificationResult[] // All results including Uncategorized, for persistence
  tokenUsage: { inputTokens: number; outputTokens: number }
}
```

Import `multiLabelClassificationSchema`, `ChunkClassificationResult`, `CLASSIFICATION_THRESHOLDS` from `./types`.
Import `createBatchClassifierPrompt` from `./prompts`.
  </action>
  <verify>Run `pnpm build` and verify compilation. The function signature and return type should be backward-compatible (clauses array still works for risk-scorer). Check that `rawClassifications` is present in the output type.</verify>
  <done>`runClassifierAgent` processes chunks in batches of 4 with two-stage RAG (7 references per chunk), neighbor context (200 chars each side), and candidate category narrowing. Returns both filtered `clauses` and full `rawClassifications`.</done>
</task>

</tasks>

<verification>
1. `pnpm build` passes without errors
2. `createBatchClassifierPrompt` is exported from `agents/prompts/classifier.ts`
3. `runClassifierAgent` returns `ClassifierOutput` with both `clauses` and `rawClassifications`
4. `buildNeighborMap` builds context with 200-char slices from adjacent chunks
5. Batch size is 4 (configurable constant at top of file)
6. Two-stage RAG: vector search returns 7 results per chunk, deduplicates across batch
7. Chunks below 0.3 confidence are categorized as "Uncategorized"
8. Existing `ClassifiedClause` interface unchanged
</verification>

<success_criteria>
- Classifier processes chunks in batches (not one-at-a-time) reducing API calls by ~75%
- Each chunk has neighbor context from surrounding chunks
- Vector search narrows candidate categories before LLM classification
- Both CUAD and ContractNLI references are used (via `findSimilarClauses`)
- Low-confidence chunks handled per CLASSIFICATION_THRESHOLDS
- Output maintains backward compatibility for risk-scorer agent
</success_criteria>

<output>
After completion, create `.planning/phases/06-cuad-classification/06-02-SUMMARY.md`
</output>
