---
phase: 07-risk-scoring
plan: 04
type: execute
wave: 3
depends_on: ["07-02", "07-03"]
files_modified:
  - db/queries/risk-scoring.ts
  - inngest/functions/rescore-analysis.ts
  - app/(main)/(dashboard)/analyses/actions.ts
  - components/artifact/analysis-view.tsx
autonomous: true

must_haves:
  truths:
    - "User can toggle perspective (receiving/disclosing/balanced) and see re-scored results"
    - "Each clause shows expandable evidence with source labels (CUAD, ContractNLI, Bonterms)"
    - "Document shows overall risk score with risk distribution (count per level)"
    - "Executive summary highlights top 3-5 riskiest clauses"
    - "Re-scoring only triggers when perspective actually changes (no-op if same)"
    - "Re-scoring runs via Inngest to avoid serverless timeout"
    - "Risk level badges show correct colors for standard/cautious/aggressive/unknown"
  artifacts:
    - path: "inngest/functions/rescore-analysis.ts"
      provides: "Inngest function for re-scoring with different perspective"
      contains: "rescoreAnalysis"
    - path: "app/(main)/(dashboard)/analyses/actions.ts"
      provides: "Server action to trigger re-score and fetch risk data"
      contains: "triggerRescore"
    - path: "components/artifact/analysis-view.tsx"
      provides: "Perspective toggle, evidence expandable, executive summary, risk distribution"
      contains: "PerspectiveToggle"
  key_links:
    - from: "components/artifact/analysis-view.tsx"
      to: "app/(main)/(dashboard)/analyses/actions.ts"
      via: "import triggerRescore, getRiskAssessments"
      pattern: "triggerRescore|getRiskAssessments"
    - from: "app/(main)/(dashboard)/analyses/actions.ts"
      to: "inngest/functions/rescore-analysis.ts"
      via: "inngest.send rescore event"
      pattern: "nda/analysis.rescore"
    - from: "inngest/functions/rescore-analysis.ts"
      to: "agents/risk-scorer.ts"
      via: "import runRiskScorerAgent"
      pattern: "runRiskScorerAgent"
---

<objective>
Add re-scoring support via Inngest, risk scoring queries, and UI components for perspective toggle, evidence display, executive summary, and risk distribution.

Purpose: Users need to see risk assessments from their perspective, understand the evidence behind each assessment, and get an executive summary of key findings.
Output: Working UI with perspective toggle, expandable evidence, executive summary, risk distribution, and Inngest-based re-scoring.
</objective>

<execution_context>
@/Users/medelman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medelman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-risk-scoring/07-CONTEXT.md
@.planning/phases/07-risk-scoring/07-RESEARCH.md
@.planning/phases/07-risk-scoring/07-01-SUMMARY.md
@.planning/phases/07-risk-scoring/07-02-SUMMARY.md
@.planning/phases/07-risk-scoring/07-03-SUMMARY.md
@app/(main)/(dashboard)/analyses/actions.ts
@components/artifact/analysis-view.tsx
@inngest/functions/analyze-nda.ts
@db/queries/risk-scoring.ts
@db/queries/classifications.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Inngest re-score function and server actions</name>
  <files>inngest/functions/rescore-analysis.ts, db/queries/risk-scoring.ts, app/(main)/(dashboard)/analyses/actions.ts</files>
  <action>
**Part A: Add query function to `db/queries/risk-scoring.ts`**

Add a `getRiskAssessments(analysisId, tenantId)` function:
- Query `clauseExtractions` for the given analysis + tenant
- Order by `startPosition` (document order)
- Return all columns
- This is what the UI calls to display risk results

**Part B: Create `inngest/functions/rescore-analysis.ts`**

Create a new Inngest function for re-scoring:

```typescript
import { inngest, CONCURRENCY, RETRY_CONFIG, withTenantContext, getRateLimitDelay } from '@/inngest'
import { runRiskScorerAgent } from '@/agents/risk-scorer'
import { persistRiskAssessments, calculateWeightedRisk } from '@/db/queries/risk-scoring'
import { BudgetTracker } from '@/lib/ai/budget'
import { analyses, chunkClassifications } from '@/db/schema/analyses'
import { documentChunks } from '@/db/schema/documents'
import { eq, and } from 'drizzle-orm'
import type { Perspective } from '@/agents/types'
import type { ClassifiedClause } from '@/agents/classifier'

export const rescoreAnalysis = inngest.createFunction(
  {
    id: 'rescore-analysis',
    name: 'Re-Score Analysis (Perspective Change)',
    concurrency: CONCURRENCY.analysis,
    retries: RETRY_CONFIG.default.retries,
  },
  { event: 'nda/analysis.rescore' },
  async ({ event, step }) => {
    const { analysisId, tenantId, perspective } = event.data as {
      analysisId: string
      tenantId: string
      perspective: Perspective
    }

    const budgetTracker = new BudgetTracker()

    return await withTenantContext(tenantId, async (ctx) => {
      // Step 1: Load existing classifications and reconstruct clauses
      const clauses = await step.run('load-classifications', async () => {
        // Get analysis for documentId
        const analysis = await ctx.db.query.analyses.findFirst({
          where: and(eq(analyses.id, analysisId), eq(analyses.tenantId, tenantId)),
          columns: { documentId: true },
        })
        if (!analysis) throw new Error(`Analysis ${analysisId} not found`)

        // Get primary classifications with chunk content
        const classifications = await ctx.db
          .select({
            chunkId: chunkClassifications.chunkId,
            category: chunkClassifications.category,
            confidence: chunkClassifications.confidence,
            chunkIndex: chunkClassifications.chunkIndex,
            startPosition: chunkClassifications.startPosition,
            endPosition: chunkClassifications.endPosition,
            content: documentChunks.content,
          })
          .from(chunkClassifications)
          .innerJoin(documentChunks, eq(chunkClassifications.chunkId, documentChunks.id))
          .where(and(
            eq(chunkClassifications.analysisId, analysisId),
            eq(chunkClassifications.tenantId, tenantId),
            eq(chunkClassifications.isPrimary, true),
          ))
          .orderBy(chunkClassifications.chunkIndex)

        // Map to ClassifiedClause format
        return classifications.map(c => ({
          chunkId: c.chunkId,
          chunkIndex: c.chunkIndex,
          category: c.category,
          secondaryCategories: [] as string[],
          confidence: c.confidence,
          clauseText: c.content,
          startPosition: c.startPosition ?? 0,
          endPosition: c.endPosition ?? 0,
        })) as ClassifiedClause[]
      })

      // Step 2: Update analysis status to processing
      await step.run('mark-rescoring', async () => {
        await ctx.db
          .update(analyses)
          .set({
            progressStage: 'scoring',
            progressPercent: 30,
            updatedAt: new Date(),
          })
          .where(eq(analyses.id, analysisId))
      })

      // Step 3: Run risk scorer with new perspective
      await step.sleep('rate-limit-rescore', getRateLimitDelay('claude'))

      const riskResult = await step.run('risk-scorer-agent', () =>
        runRiskScorerAgent({
          clauses,
          budgetTracker,
          perspective,
        })
      )

      // Step 4: Get documentId for persistence
      const analysis = await step.run('get-analysis', async () => {
        return await ctx.db.query.analyses.findFirst({
          where: eq(analyses.id, analysisId),
          columns: { documentId: true },
        })
      })

      // Step 5: Persist updated risk assessments
      await step.run('persist-risk-assessments', async () => {
        await persistRiskAssessments(
          ctx.db,
          tenantId,
          analysisId,
          analysis!.documentId,
          riskResult.assessments,
          perspective,
        )
      })

      // Step 6: Update analysis with new scores
      await step.run('update-analysis-scores', async () => {
        const weightedRisk = await calculateWeightedRisk(ctx.db, riskResult.assessments)

        await ctx.db
          .update(analyses)
          .set({
            overallRiskScore: weightedRisk.score,
            overallRiskLevel: weightedRisk.level,
            summary: riskResult.executiveSummary,
            progressStage: 'complete',
            progressPercent: 100,
            updatedAt: new Date(),
            metadata: sql`COALESCE(metadata, '{}'::jsonb) || ${JSON.stringify({
              perspective,
              riskDistribution: riskResult.riskDistribution,
            })}::jsonb`,
          })
          .where(eq(analyses.id, analysisId))
      })

      return { analysisId, perspective, success: true }
    })
  }
)
```

Import `sql` from `drizzle-orm` at the top.

**Part C: Add server actions to `app/(main)/(dashboard)/analyses/actions.ts`**

1. Add `triggerRescore(analysisId, perspective)`:
```typescript
export async function triggerRescore(
  analysisId: string,
  perspective: 'receiving' | 'disclosing' | 'balanced'
): Promise<ApiResponse<void>> {
  if (!z.string().uuid().safeParse(analysisId).success) {
    return err("VALIDATION_ERROR", "Invalid analysis ID");
  }

  const { db, tenantId } = await withTenant();

  // Verify analysis exists and is completed
  const analysis = await db.query.analyses.findFirst({
    where: and(eq(analyses.id, analysisId), eq(analyses.tenantId, tenantId)),
    columns: { id: true, status: true, metadata: true },
  });

  if (!analysis) return err("NOT_FOUND", "Analysis not found");
  if (analysis.status !== "completed") {
    return err("CONFLICT", "Can only re-score completed analyses");
  }

  // Validate perspective actually changed â€” avoid wasting resources on no-op re-score
  const currentPerspective = (analysis.metadata as any)?.perspective ?? 'balanced';
  if (currentPerspective === perspective) {
    return err("VALIDATION_ERROR", "Analysis already scored from this perspective");
  }

  // Send rescore event to Inngest
  await inngest.send({
    name: "nda/analysis.rescore",
    data: { analysisId, tenantId, perspective },
  });

  revalidatePath("/analyses");
  return ok(undefined);
}
```

2. Add `getRiskAssessments(analysisId)`:
```typescript
export async function getRiskAssessments(
  analysisId: string
): Promise<ApiResponse<ClauseExtraction[]>> {
  if (!z.string().uuid().safeParse(analysisId).success) {
    return err("VALIDATION_ERROR", "Invalid analysis ID");
  }

  const { db, tenantId } = await withTenant();

  const analysis = await db.query.analyses.findFirst({
    where: and(eq(analyses.id, analysisId), eq(analyses.tenantId, tenantId)),
    columns: { id: true },
  });

  if (!analysis) return err("NOT_FOUND", "Analysis not found");

  const assessments = await db
    .select()
    .from(clauseExtractions)
    .where(and(
      eq(clauseExtractions.analysisId, analysisId),
      eq(clauseExtractions.tenantId, tenantId),
    ))
    .orderBy(clauseExtractions.startPosition);

  return ok(assessments);
}
```

3. Export the `Perspective` type for UI consumption:
```typescript
export type { Perspective } from "@/agents/types";
```
  </action>
  <verify>
    - `pnpm build` succeeds
    - `pnpm lint` passes
    - `inngest/functions/rescore-analysis.ts` exists and exports `rescoreAnalysis`
    - Server actions `triggerRescore` and `getRiskAssessments` exported from actions.ts
  </verify>
  <done>
    - Inngest re-score function loads existing classifications and runs risk scorer with new perspective
    - Server action triggers re-score via Inngest event, only when perspective actually changed (returns early if same)
    - Server action fetches risk assessments for UI display
    - Re-scoring updates clauseExtractions via upsert (overwrites previous perspective's results)
  </done>
</task>

<task type="auto">
  <name>Task 2: Add perspective toggle and executive summary card</name>
  <files>components/artifact/analysis-view.tsx</files>
  <action>
Enhance `components/artifact/analysis-view.tsx` with perspective toggle and executive summary. Add to the existing component structure (do NOT rewrite the entire file -- add new sections):

1. **Perspective Toggle** (at the top of the analysis view, next to the existing view toggles):
   - Three-button toggle group: "Receiving" | "Balanced" | "Disclosing"
   - Read current perspective from analysis metadata: `(analysis.metadata as any)?.perspective ?? 'balanced'`
   - On toggle: call `triggerRescore(analysisId, perspective)` server action
   - Handle the "already scored from this perspective" error gracefully (show toast, no spinner)
   - Show a loading spinner with "Re-scoring from {perspective} perspective..." while re-scoring
   - Debounce rapid clicks (disable toggle for 2 seconds after click)
   - Import `triggerRescore` from the server actions

2. **Executive Summary Card** (new card at the top of the results area, shown when analysis is completed):
   - Title: "Executive Summary"
   - Show `analysis.summary` text (populated by risk scorer)
   - Show overall risk score badge: `{score}/100 - {level}` with appropriate color
   - Show risk distribution as small color-coded badges: "12 standard, 5 cautious, 2 aggressive"
   - Read distribution from `(analysis.metadata as any)?.riskDistribution`
   - If no summary, show placeholder: "Summary will appear when analysis completes."

3. **Imports to add**:
```typescript
import { triggerRescore } from "@/app/(main)/(dashboard)/analyses/actions"
```

**State management for perspective toggle**:
- Perspective state tracked locally, synced from analysis metadata on load
- Re-score triggers optimistic UI update (toggle moves immediately, data refreshes when Inngest completes)
- Poll for completion: after triggering rescore, poll `getAnalysis` every 3 seconds until progressStage returns to 'complete'

**Styling guidance**:
- Risk level colors should use oklch colors consistent with Tailwind v4 theme
- Standard = green tones, Cautious = amber/yellow tones, Aggressive = red tones, Unknown = gray tones
- The existing `riskConfig` object in the file already has these colors -- reuse it
  </action>
  <verify>
    - `pnpm build` succeeds
    - `pnpm lint` passes
    - Analysis view shows perspective toggle with three options
    - Executive summary card displays with overall score and risk distribution badges
    - Toggling perspective to same value shows error (no re-score triggered)
  </verify>
  <done>
    - Perspective toggle triggers Inngest re-score and shows loading state
    - Perspective toggle returns early with message when selecting current perspective
    - Executive summary displays at top with overall score and risk distribution
    - Poll-based refresh after re-score completion
  </done>
</task>

<task type="auto">
  <name>Task 3: Add risk assessment list with expandable evidence</name>
  <files>components/artifact/analysis-view.tsx</files>
  <action>
Continue enhancing `components/artifact/analysis-view.tsx` with the risk assessment list and evidence expandable sections:

1. **Risk Assessment List** (enhance the existing clause list OR add a "Risk" tab/view):
   - Fetch risk assessments via `getRiskAssessments(analysisId)` using useEffect (matching existing pattern)
   - For each clause extraction with a riskLevel:
     - Show risk level badge with color (reuse existing `riskConfig` from the file)
     - Show confidence as a small percentage badge
     - Show explanation text (2-3 sentences)
     - If `metadata.negotiationSuggestion` exists, show it with a lightbulb icon or "Tip:" prefix
     - If `metadata.atypicalLanguage` is true, show a small warning badge "Atypical Wording"

2. **Evidence Expandable** (for each risk assessment):
   - Use the existing `Collapsible` component (already imported)
   - Trigger text: "See evidence" / "Hide evidence"
   - Evidence content:
     - **Citations**: List each citation with quoted text styling (italic, left border)
     - **References**: List each reference with source label badge (CUAD/ContractNLI/Bonterms), similarity percentage, and summary text
     - **Baseline Comparison**: If present, show as a highlighted comparison block
   - Parse evidence from `clauseExtraction.evidence` JSONB field
   - Handle gracefully when evidence is null or empty

3. **Imports to add**:
```typescript
import { getRiskAssessments } from "@/app/(main)/(dashboard)/analyses/actions"
```

Use the existing UI component imports (Badge, Card, Collapsible, etc.) already in the file.

**Styling guidance**:
- Evidence expandable should use subtle background (bg-muted/5) to visually separate from main content
- Source labels: CUAD = blue badge, ContractNLI = purple badge, Bonterms = green badge

**State management**:
- Risk assessments fetched via `useState` + `useEffect` (matching existing pattern for classifications)
- Re-fetch assessments when perspective changes (listen for poll completion from Task 2's perspective toggle)
  </action>
  <verify>
    - `pnpm build` succeeds
    - `pnpm lint` passes
    - Each clause shows risk level badge, confidence, and explanation
    - Evidence expandable renders citations and references with source labels
    - Atypical language badge appears when flagged
    - Negotiation suggestion appears when present
  </verify>
  <done>
    - Each clause shows risk level, confidence, explanation, and optional negotiation suggestion
    - Evidence expandable reveals citations, references with source labels, and baseline comparison
    - Atypical language flag shown as warning badge
    - Empty evidence handled gracefully (no crash, shows "No evidence available")
  </done>
</task>

</tasks>

<verification>
- `pnpm build` succeeds
- `pnpm lint` passes
- Re-score Inngest function registered and callable
- Server actions for re-scoring and fetching risk data work
- Analysis view shows perspective toggle, executive summary, evidence expandable
- Risk distribution displays count per level
</verification>

<success_criteria>
- User can toggle perspective and see re-scored results (via Inngest, avoids timeout)
- Each clause shows risk level badge, explanation, and expandable evidence
- Evidence shows source-labeled references (CUAD, ContractNLI, Bonterms)
- Executive summary highlights top riskiest clauses
- Risk distribution shows color-coded count per level
- Non-standard clauses include negotiation suggestions
</success_criteria>

<output>
After completion, create `.planning/phases/07-risk-scoring/07-04-SUMMARY.md`
</output>
