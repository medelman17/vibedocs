---
phase: 02-budget-protection
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - inngest/functions/analyze-nda.ts
  - inngest/functions/analyze-nda.test.ts
autonomous: true

must_haves:
  truths:
    - "Post-parse token budget check runs after parser step"
    - "Oversized documents are truncated at section boundaries"
    - "Truncation warning is stored in analysis metadata"
    - "Estimated tokens and actual tokens are persisted"
  artifacts:
    - path: "inngest/functions/analyze-nda.ts"
      provides: "Budget-protected analysis pipeline"
      contains: ["validateTokenBudget", "estimatedTokens", "wasTruncated"]
  key_links:
    - from: "inngest/functions/analyze-nda.ts"
      to: "agents/validation/gates"
      via: "import validateTokenBudget"
      pattern: "validateTokenBudget"
    - from: "inngest/functions/analyze-nda.ts"
      to: "db/schema/analyses"
      via: "persist budget data"
      pattern: "estimatedTokens.*actualTokens"
---

<objective>
Integrate token budget validation and truncation into the analyze-nda pipeline.

Purpose: Enforce post-parse token budget, truncate oversized documents, and persist budget tracking data.

Output: analyze-nda.ts with budget check after parser, truncation logic, and cost tracking persistence.
</objective>

<execution_context>
@/Users/medelman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medelman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-budget-protection/02-01-PLAN.md
@inngest/functions/analyze-nda.ts
@agents/validation/gates.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add token budget validation after parser step</name>
  <files>inngest/functions/analyze-nda.ts</files>
  <action>
Modify analyze-nda.ts to add token budget validation after the parser step:

1. Add import at top:
```typescript
import { validateTokenBudget, type TokenBudgetValidation } from '@/agents/validation'
```

2. After the parser validation gate (around line 139), add token budget validation:

```typescript
// Token budget validation gate - runs AFTER parser validation
// This gate always passes but may truncate the document
const budgetValidation = validateTokenBudget(
  parserResult.document.rawText,
  parserResult.document.chunks.map(c => ({
    id: c.id,
    content: c.content,
    tokenCount: c.tokenCount ?? 0,
    sectionPath: c.sectionPath,
  }))
)

// Track working document - may be truncated
let workingDocument = parserResult.document
let wasTruncated = false

if (budgetValidation.truncation) {
  // Document was truncated to fit budget
  workingDocument = {
    ...parserResult.document,
    rawText: budgetValidation.truncation.text,
    chunks: budgetValidation.truncation.chunks.map((c, i) => ({
      ...parserResult.document.chunks.find(orig => orig.id === c.id) ?? parserResult.document.chunks[i],
      content: c.content,
    })),
  }
  wasTruncated = true

  console.log('[Budget] Document truncated', {
    analysisId,
    originalTokens: budgetValidation.estimate.tokenCount,
    truncatedTokens: budgetValidation.truncation.truncatedTokens,
    removedSections: budgetValidation.truncation.removedSections,
  })
}

// Store estimate and truncation status in a durable step
await step.run('record-budget-estimate', async () => {
  await ctx.db
    .update(analyses)
    .set({
      estimatedTokens: budgetValidation.estimate.tokenCount,
      wasTruncated,
      ...(wasTruncated && {
        metadata: {
          truncationWarning: budgetValidation.warning?.message,
          removedSections: budgetValidation.truncation?.removedSections,
        },
      }),
    })
    .where(eq(analyses.id, analysisId))
})
```

3. Update the progress message after parser to reflect truncation:
```typescript
await emitProgress(
  'parsing',
  20,
  wasTruncated
    ? `Parsed and truncated to ${workingDocument.chunks.length} chunks`
    : `Parsed ${parserResult.document.chunks.length} chunks`
)
```

4. Update classifier call to use workingDocument:
```typescript
const classifierResult = await step.run('classifier-agent', () =>
  runClassifierAgent({
    parsedDocument: workingDocument,  // Use truncated version
    budgetTracker,
  })
)
```
  </action>
  <verify>
Check TypeScript compiles:
```bash
pnpm tsc --noEmit inngest/functions/analyze-nda.ts
```
  </verify>
  <done>
Token budget validation added after parser step. Oversized documents are truncated and truncation metadata is persisted.
  </done>
</task>

<task type="auto">
  <name>Task 2: Persist actual tokens and cost on completion</name>
  <files>inngest/functions/analyze-nda.ts</files>
  <action>
Update the final persist step to record actual token usage and cost:

Find the `persist-final` step (around line 216) and update the set clause:

```typescript
await step.run('persist-final', async () => {
  const usage = budgetTracker.getUsage()

  await ctx.db
    .update(analyses)
    .set({
      status: 'completed',
      overallRiskScore: riskResult.overallRiskScore,
      overallRiskLevel: riskResult.overallRiskLevel,
      gapAnalysis: gapResult.gapAnalysis,
      tokenUsage: usage,
      // NEW: Budget tracking fields
      actualTokens: usage.total.total,
      estimatedCost: usage.total.estimatedCost,
      processingTimeMs: Date.now() - startTime,
      completedAt: new Date(),
    })
    .where(eq(analyses.id, analysisId))
})
```

This persists:
- `actualTokens` - Total tokens used across all agents (input + output)
- `estimatedCost` - Cost calculated by BudgetTracker using Claude pricing
- `tokenUsage` - Detailed breakdown by agent (already exists, unchanged)
  </action>
  <verify>
Check TypeScript compiles:
```bash
pnpm tsc --noEmit inngest/functions/analyze-nda.ts
```
  </verify>
  <done>
Final persist step updated to include actualTokens and estimatedCost fields.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update tests for budget integration</name>
  <files>inngest/functions/analyze-nda.test.ts</files>
  <action>
Update the analyze-nda tests to account for the new budget validation:

1. Update the mock db object to handle the new `record-budget-estimate` step:
The existing mock should work since it uses `onConflictDoNothing` and generic update.

2. Add a test case for truncation scenario (if time permits, optional):

```typescript
it('truncates oversized documents and stores warning', async () => {
  // Mock a large document that exceeds token budget
  const largeContent = 'word '.repeat(250_000) // ~250K tokens

  vi.mocked(runParserAgent).mockResolvedValue({
    document: {
      id: 'test-doc',
      title: 'Test',
      rawText: largeContent,
      chunks: [
        { id: 'chunk-1', content: largeContent.slice(0, 100000), tokenCount: 100000 },
        { id: 'chunk-2', content: largeContent.slice(100000), tokenCount: 150000 },
      ],
    },
    usage: { input: 1000, output: 500 },
  })

  // Run the function and verify truncation metadata was stored
  // ... test implementation
})
```

Note: The existing tests should pass because:
- The budget validation always passes (it truncates, doesn't fail)
- The new db fields are nullable
- The mock update handles any fields

Run tests to verify no regressions:
```bash
pnpm test inngest/functions/analyze-nda.test.ts
```
  </action>
  <verify>
```bash
pnpm test inngest/functions/analyze-nda.test.ts
```
All existing tests pass.
  </verify>
  <done>
Tests updated/verified. Existing tests pass with budget integration. New budget fields are persisted on analysis completion.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors
2. All analyze-nda tests pass
3. Pipeline flow: parser -> budget check -> classifier uses workingDocument
4. Completion persists actualTokens and estimatedCost
</verification>

<success_criteria>
- Token budget validation runs after parser step
- Truncation warning stored in metadata when document exceeds budget
- Classifier receives truncated document when applicable
- Final persist includes actualTokens and estimatedCost
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-budget-protection/02-03-SUMMARY.md`
</output>
