---
phase: 02-budget-protection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/budget/index.ts
  - lib/budget/limits.ts
  - lib/budget/estimation.ts
  - lib/budget/validation.ts
  - lib/budget/truncation.ts
  - db/schema/analyses.ts
autonomous: true

must_haves:
  truths:
    - "Budget limits are centrally defined and importable"
    - "Token estimation produces count from document text"
    - "Truncation respects section boundaries from chunks"
    - "Analyses table stores token/cost tracking fields"
  artifacts:
    - path: "lib/budget/limits.ts"
      provides: "BUDGET_LIMITS constants"
      exports: ["BUDGET_LIMITS", "MAX_FILE_SIZE", "MAX_PAGES", "TOKEN_BUDGET"]
    - path: "lib/budget/estimation.ts"
      provides: "Token estimation using gpt-tokenizer"
      exports: ["estimateTokens", "checkTokenBudget"]
    - path: "lib/budget/truncation.ts"
      provides: "Section-boundary truncation logic"
      exports: ["truncateToTokenBudget"]
    - path: "lib/budget/validation.ts"
      provides: "Upload validation utilities"
      exports: ["validateFileSize", "validatePageCount"]
    - path: "db/schema/analyses.ts"
      provides: "Token tracking columns"
      contains: ["estimatedTokens", "actualTokens", "estimatedCost", "wasTruncated"]
  key_links:
    - from: "lib/budget/truncation.ts"
      to: "DocumentChunk type"
      via: "truncation uses chunk boundaries"
      pattern: "chunks.*sectionPath"
    - from: "lib/budget/estimation.ts"
      to: "gpt-tokenizer"
      via: "encode function"
      pattern: "import.*gpt-tokenizer"
---

<objective>
Create budget protection infrastructure: limits constants, token estimation, truncation logic, and schema additions.

Purpose: Establish the foundational utilities that the pipeline and upload validation will use to enforce budget limits.

Output: lib/budget/ module with all utilities, analyses schema with new columns.
</objective>

<execution_context>
@/Users/medelman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medelman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-budget-protection/02-RESEARCH.md
@db/schema/analyses.ts
@lib/ai/budget.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create budget limits and estimation utilities</name>
  <files>
    lib/budget/limits.ts
    lib/budget/estimation.ts
    lib/budget/validation.ts
    lib/budget/truncation.ts
    lib/budget/index.ts
  </files>
  <action>
Create the lib/budget/ module with five files:

1. **lib/budget/limits.ts** - Budget constants:
```typescript
export const BUDGET_LIMITS = {
  MAX_FILE_SIZE: 10 * 1024 * 1024,  // 10MB (existing limit)
  MAX_PAGES: 50,                     // Page limit for PDFs
  TOKEN_BUDGET: 200_000,             // Post-parse token limit
} as const

// Named exports for convenience
export const MAX_FILE_SIZE = BUDGET_LIMITS.MAX_FILE_SIZE
export const MAX_PAGES = BUDGET_LIMITS.MAX_PAGES
export const TOKEN_BUDGET = BUDGET_LIMITS.TOKEN_BUDGET
```

2. **lib/budget/estimation.ts** - Token estimation:
```typescript
import { encode } from 'gpt-tokenizer'
import { BUDGET_LIMITS } from './limits'

export interface TokenEstimate {
  tokenCount: number
  withinBudget: boolean
  budgetRemaining: number
  truncationNeeded: boolean
}

/**
 * Estimates token count for document text.
 * Uses gpt-tokenizer as proxy - Claude tokenizer may differ by ~10-15%
 * but this is sufficient for budget enforcement.
 */
export function estimateTokens(text: string): number {
  return encode(text).length
}

export function checkTokenBudget(
  text: string,
  budget: number = BUDGET_LIMITS.TOKEN_BUDGET
): TokenEstimate {
  const tokenCount = estimateTokens(text)
  const withinBudget = tokenCount <= budget

  return {
    tokenCount,
    withinBudget,
    budgetRemaining: Math.max(0, budget - tokenCount),
    truncationNeeded: !withinBudget,
  }
}
```

3. **lib/budget/validation.ts** - Upload validation:
```typescript
import { BUDGET_LIMITS } from './limits'

export interface UploadValidationResult {
  valid: boolean
  error?: {
    code: 'FILE_TOO_LARGE' | 'TOO_MANY_PAGES'
    message: string
    limit: number
    actual: number
  }
}

export function validateFileSize(sizeBytes: number): UploadValidationResult {
  if (sizeBytes > BUDGET_LIMITS.MAX_FILE_SIZE) {
    const limitMB = BUDGET_LIMITS.MAX_FILE_SIZE / (1024 * 1024)
    return {
      valid: false,
      error: {
        code: 'FILE_TOO_LARGE',
        message: `File exceeds ${limitMB}MB limit. Please upload a smaller document.`,
        limit: BUDGET_LIMITS.MAX_FILE_SIZE,
        actual: sizeBytes,
      }
    }
  }
  return { valid: true }
}

export async function validatePageCount(
  buffer: Buffer,
  mimeType: string
): Promise<UploadValidationResult> {
  // Only check PDF - DOCX page count requires rendering
  if (mimeType === 'application/pdf') {
    // Dynamic import to avoid loading pdf-parse unless needed
    const pdfParse = (await import('pdf-parse')).default
    const pdf = await pdfParse(buffer)
    const pageCount = pdf.numpages

    if (pageCount > BUDGET_LIMITS.MAX_PAGES) {
      return {
        valid: false,
        error: {
          code: 'TOO_MANY_PAGES',
          message: `Document exceeds ${BUDGET_LIMITS.MAX_PAGES} page limit. Please upload a shorter document.`,
          limit: BUDGET_LIMITS.MAX_PAGES,
          actual: pageCount,
        }
      }
    }
  }

  return { valid: true }
}
```

4. **lib/budget/truncation.ts** - Section-boundary truncation:
```typescript
import { encode } from 'gpt-tokenizer'
import { BUDGET_LIMITS } from './limits'

export interface DocumentChunk {
  id: string
  content: string
  tokenCount: number
  sectionPath?: string[]
}

export interface TruncationResult {
  text: string
  chunks: DocumentChunk[]
  truncated: boolean
  originalTokens: number
  truncatedTokens: number
  removedSections: string[]
}

/**
 * Truncates document at section boundaries to fit within token budget.
 *
 * Strategy:
 * 1. Work with existing chunks (already split at section boundaries)
 * 2. Include chunks from start until budget exhausted
 * 3. Stop at the last complete section boundary
 * 4. Record which sections were removed
 */
export function truncateToTokenBudget(
  rawText: string,
  chunks: DocumentChunk[],
  budget: number = BUDGET_LIMITS.TOKEN_BUDGET
): TruncationResult {
  const originalTokens = encode(rawText).length

  if (originalTokens <= budget) {
    return {
      text: rawText,
      chunks,
      truncated: false,
      originalTokens,
      truncatedTokens: originalTokens,
      removedSections: [],
    }
  }

  // Accumulate chunks until we exceed budget
  let accumulatedTokens = 0
  let lastIncludedIndex = -1

  for (let i = 0; i < chunks.length; i++) {
    const chunkTokens = chunks[i].tokenCount
    if (accumulatedTokens + chunkTokens > budget) {
      break
    }
    accumulatedTokens += chunkTokens
    lastIncludedIndex = i
  }

  // Handle edge case: even first chunk exceeds budget
  if (lastIncludedIndex < 0) {
    lastIncludedIndex = 0
    accumulatedTokens = chunks[0]?.tokenCount ?? 0
  }

  const includedChunks = chunks.slice(0, lastIncludedIndex + 1)
  const removedChunks = chunks.slice(lastIncludedIndex + 1)

  // Build truncated text from included chunks
  const truncatedText = includedChunks.map(c => c.content).join('\n\n')

  // Extract section names from removed chunks
  const removedSections = [...new Set(
    removedChunks
      .flatMap(c => c.sectionPath ?? [])
      .filter(Boolean)
  )]

  return {
    text: truncatedText,
    chunks: includedChunks,
    truncated: true,
    originalTokens,
    truncatedTokens: accumulatedTokens,
    removedSections,
  }
}
```

5. **lib/budget/index.ts** - Barrel export:
```typescript
export * from './limits'
export * from './estimation'
export * from './validation'
export * from './truncation'
```

Note: Only export lightweight utilities. The validation.ts uses dynamic import for pdf-parse to avoid barrel export issues.
  </action>
  <verify>
Run TypeScript check:
```bash
pnpm tsc --noEmit lib/budget/*.ts
```
Check imports resolve:
```bash
grep -l "gpt-tokenizer" lib/budget/*.ts  # Should find estimation.ts and truncation.ts
```
  </verify>
  <done>
All budget utilities export without TypeScript errors. Functions are importable from @/lib/budget.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add token tracking columns to analyses schema</name>
  <files>db/schema/analyses.ts</files>
  <action>
Add four new columns to the `analyses` table for budget tracking:

1. **estimatedTokens** (integer, nullable) - Pre-flight token estimate after parsing
2. **actualTokens** (integer, nullable) - Actual tokens used (from BudgetTracker)
3. **estimatedCost** (real, nullable) - Cost estimate in dollars
4. **wasTruncated** (boolean, default false) - Whether document was truncated

Add to the analyses pgTable definition, after `tokenUsage`:

```typescript
/**
 * Estimated input tokens before analysis (post-parse count).
 * Uses gpt-tokenizer as proxy for Claude tokens (~10-15% variance).
 */
estimatedTokens: integer("estimated_tokens"),

/**
 * Actual tokens used (sum of all agent calls).
 * Populated from BudgetTracker usage data after completion.
 */
actualTokens: integer("actual_tokens"),

/**
 * Estimated cost in dollars (input + output at Claude pricing).
 * Updated as agents complete.
 */
estimatedCost: real("estimated_cost"),

/**
 * Whether the document was truncated to fit token budget.
 * If true, metadata.truncationWarning contains details.
 */
wasTruncated: boolean("was_truncated").default(false),
```

Import `boolean` from drizzle-orm/pg-core if not already imported.
  </action>
  <verify>
Run schema generation:
```bash
pnpm db:generate
```
Check columns exist in generated SQL.
  </verify>
  <done>
Schema generates without errors. New columns appear in migration SQL: estimated_tokens, actual_tokens, estimated_cost, was_truncated.
  </done>
</task>

<task type="auto">
  <name>Task 3: Push schema changes and run tests</name>
  <files>None (runtime operation)</files>
  <action>
Push schema changes to database and verify tests pass:

1. Push schema:
```bash
pnpm db:push
```

2. Run existing tests to ensure no regressions:
```bash
pnpm test
```

3. Add a basic test for budget utilities in lib/budget/estimation.test.ts:
```typescript
import { describe, it, expect } from 'vitest'
import { estimateTokens, checkTokenBudget } from './estimation'

describe('estimateTokens', () => {
  it('returns positive count for non-empty text', () => {
    const count = estimateTokens('Hello, world!')
    expect(count).toBeGreaterThan(0)
  })

  it('returns 0 for empty text', () => {
    expect(estimateTokens('')).toBe(0)
  })
})

describe('checkTokenBudget', () => {
  it('returns withinBudget true for small text', () => {
    const result = checkTokenBudget('Hello', 1000)
    expect(result.withinBudget).toBe(true)
    expect(result.truncationNeeded).toBe(false)
  })

  it('returns truncationNeeded true when over budget', () => {
    const longText = 'word '.repeat(1000) // ~1000 tokens
    const result = checkTokenBudget(longText, 100)
    expect(result.withinBudget).toBe(false)
    expect(result.truncationNeeded).toBe(true)
  })
})
```

Run tests:
```bash
pnpm test lib/budget/
```
  </action>
  <verify>
```bash
pnpm test
```
All tests pass including new budget tests.
  </verify>
  <done>
Schema pushed to database. All tests pass including new budget estimation tests.
  </done>
</task>

</tasks>

<verification>
1. `import { BUDGET_LIMITS, estimateTokens, truncateToTokenBudget } from '@/lib/budget'` resolves
2. Schema includes estimated_tokens, actual_tokens, estimated_cost, was_truncated columns
3. `pnpm test` passes with new budget tests
4. No TypeScript errors in lib/budget/ or db/schema/analyses.ts
</verification>

<success_criteria>
- lib/budget/ module exists with 5 files (limits, estimation, validation, truncation, index)
- All functions export from the barrel and are type-safe
- analyses schema has 4 new columns for budget tracking
- Tests pass including basic estimation tests
</success_criteria>

<output>
After completion, create `.planning/phases/02-budget-protection/02-01-SUMMARY.md`
</output>
