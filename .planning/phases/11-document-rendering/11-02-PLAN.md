---
phase: 11-document-rendering
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - hooks/use-clause-selection.ts
  - hooks/use-document-search.ts
autonomous: true

must_haves:
  truths:
    - "Clause selection state is shared between document and analysis panels"
    - "Text search finds matches in document text with prev/next navigation"
    - "Selection source tracks which panel initiated the selection"
  artifacts:
    - path: "hooks/use-clause-selection.ts"
      provides: "Zustand store for shared clause selection state"
      exports: ["useClauseSelection"]
    - path: "hooks/use-document-search.ts"
      provides: "Document text search hook with match tracking"
      exports: ["useDocumentSearch"]
  key_links:
    - from: "hooks/use-clause-selection.ts"
      to: "zustand"
      via: "create() store"
      pattern: "create.*ClauseSelectionState"
---

<objective>
Create the shared state hooks for clause selection and document search that enable bidirectional navigation between document and analysis panels.

Purpose: Bidirectional navigation requires a single source of truth for which clause is selected and which panel initiated the selection. The document search hook enables the built-in text search feature.

Output: Two React hooks -- useClauseSelection (zustand store) and useDocumentSearch (text search with match navigation).
</objective>

<execution_context>
@/Users/medelman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medelman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-document-rendering/11-RESEARCH.md

# Existing stores pattern
@lib/stores/shell-store.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create clause selection zustand store</name>
  <files>hooks/use-clause-selection.ts</files>
  <action>
    Create `hooks/use-clause-selection.ts` as a zustand store (matching the pattern in `lib/stores/shell-store.ts` but simpler -- no persistence needed since selection is transient).

    State:
    - `activeClauseId: string | null` - currently selected clause
    - `selectionSource: 'document' | 'analysis' | null` - which panel triggered selection
    - `highlightsEnabled: boolean` - global toggle, defaults to `false` (user decision: default off)
    - `activeTab: 'classifications' | 'risk' | 'gaps' | 'chat'` - active analysis tab, defaults to 'risk'

    Actions:
    - `selectClause(clauseId: string, source: 'document' | 'analysis')` - sets activeClauseId and selectionSource
    - `clearSelection()` - clears activeClauseId and selectionSource (called on Escape key)
    - `toggleHighlights()` - toggles highlightsEnabled
    - `setHighlightsEnabled(enabled: boolean)` - explicitly set highlights
    - `setActiveTab(tab)` - set active analysis tab
    - `askAboutClause(clauseId: string, clauseText: string)` - sets activeClauseId, switches to chat tab, stores clauseText for chat context

    Additional state for "Ask about this":
    - `pendingClauseContext: { clauseId: string; clauseText: string } | null` - clause queued for chat

    Use `create<State>()` from zustand (NOT persist middleware -- selection state is ephemeral).
    Import from 'zustand' directly.
  </action>
  <verify>pnpm build (type-check passes)</verify>
  <done>useClauseSelection store created with all state and actions. No persistence middleware. Types exported for consumers.</done>
</task>

<task type="auto">
  <name>Task 2: Create document search hook</name>
  <files>hooks/use-document-search.ts</files>
  <action>
    Create `hooks/use-document-search.ts` as a custom React hook (not zustand -- it's component-local state).

    Interface:
    ```typescript
    interface SearchMatch {
      index: number           // Sequential match index
      start: number           // Character offset in text
      end: number             // Character offset in text
      paragraphIndex: number  // Which paragraph segment contains this match
    }

    function useDocumentSearch(text: string, paragraphOffsets: number[]): {
      query: string
      setQuery: (q: string) => void
      matches: SearchMatch[]
      activeMatchIndex: number
      nextMatch: () => void
      prevMatch: () => void
      totalMatches: number
      activeMatch: SearchMatch | null  // convenience: matches[activeMatchIndex]
    }
    ```

    Implementation:
    - Minimum 2 character query before searching (avoid flooding on single char)
    - Case-insensitive search using toLowerCase()
    - Find all occurrences of query in text, track character offsets
    - For each match, determine which paragraph it belongs to using paragraphOffsets array
    - nextMatch/prevMatch wrap around (modular arithmetic)
    - activeMatch is a derived value from matches[activeMatchIndex]
    - Use useMemo for match computation (not useEffect + setState) to avoid stale state
    - Reset activeMatchIndex to 0 when query changes

    Do NOT use useEffect for match computation. Use useMemo for the matches array and derive activeMatch from it.
  </action>
  <verify>pnpm build (type-check passes)</verify>
  <done>useDocumentSearch hook created with case-insensitive search, paragraph-aware match tracking, and prev/next navigation with wraparound. Uses useMemo for performance.</done>
</task>

</tasks>

<verification>
- `pnpm build` succeeds
- useClauseSelection store exports all required state and actions
- useDocumentSearch hook computes matches correctly with paragraph tracking
- No barrel exports created
</verification>

<success_criteria>
- Single shared clause selection state available for both panels
- Document search computes matches with paragraph index mapping
- Hooks follow project conventions (zustand pattern, no barrel exports)
</success_criteria>

<output>
After completion, create `.planning/phases/11-document-rendering/11-02-SUMMARY.md`
</output>
