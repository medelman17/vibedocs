---
phase: 11-document-rendering
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - lib/document-rendering/types.ts
  - lib/document-rendering/text-to-markdown.ts
  - lib/document-rendering/offset-mapper.ts
  - lib/document-rendering/text-to-markdown.test.ts
  - lib/document-rendering/offset-mapper.test.ts
  - app/(main)/(dashboard)/analyses/actions.ts
autonomous: true

must_haves:
  truths:
    - "Raw text converts to markdown with heading syntax from DocumentStructure"
    - "Character offset mapping correctly translates clause positions through markdown conversion"
    - "Server action returns document rawText, structure, and clause positions for rendering"
  artifacts:
    - path: "lib/document-rendering/types.ts"
      provides: "Rendering type definitions (OffsetMapping, MarkdownConversion, ClauseOverlay, DocumentSegment)"
    - path: "lib/document-rendering/text-to-markdown.ts"
      provides: "convertToMarkdown function and splitIntoParagraphs for virtualization"
      exports: ["convertToMarkdown", "splitIntoParagraphs"]
    - path: "lib/document-rendering/offset-mapper.ts"
      provides: "translateOffset and mapClausePositions utilities"
      exports: ["translateOffset", "mapClausePositions"]
    - path: "app/(main)/(dashboard)/analyses/actions.ts"
      provides: "getDocumentForRendering server action"
      exports: ["getDocumentForRendering"]
  key_links:
    - from: "lib/document-rendering/text-to-markdown.ts"
      to: "lib/document-rendering/offset-mapper.ts"
      via: "offset map produced by convertToMarkdown consumed by translateOffset"
      pattern: "offsetMap.*OffsetMapping"
    - from: "app/(main)/(dashboard)/analyses/actions.ts"
      to: "db/schema"
      via: "queries for documents, clauseExtractions, analyses"
      pattern: "clauseExtractions.*startPosition"
---

<objective>
Build the data layer and text-to-markdown conversion utilities with offset mapping that preserves clause position accuracy through the markdown transformation.

Purpose: This is the critical foundation -- clause highlighting in the document view depends on accurate character offset translation between rawText (stored in DB) and rendered markdown. Getting this wrong means highlights appear on the wrong text.

Output: Type definitions, tested conversion utilities, and a server action that fetches all data needed to render a document with clause overlays.
</objective>

<execution_context>
@/Users/medelman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medelman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-document-rendering/11-RESEARCH.md

# Key existing files
@lib/document-processing.ts
@db/schema/documents.ts
@db/schema/analyses.ts
@app/(main)/(dashboard)/analyses/actions.ts
@db/queries/risk-scoring.ts
@db/queries/classifications.ts
</context>

<feature>
  <name>Text-to-Markdown Conversion with Offset Mapping</name>
  <files>
    lib/document-rendering/types.ts
    lib/document-rendering/text-to-markdown.ts
    lib/document-rendering/text-to-markdown.test.ts
    lib/document-rendering/offset-mapper.ts
    lib/document-rendering/offset-mapper.test.ts
  </files>
  <behavior>
    convertToMarkdown(rawText, sections) -> { markdown, offsetMap, paragraphs }
    - Inserts heading prefixes (# ## ###) based on DocumentStructure.sections
    - Tracks every character insertion in offsetMap array
    - Splits result into paragraph segments for virtualization
    - Preserves all original text verbatim

    translateOffset(originalOffset, offsetMap) -> markdownOffset
    - Binary search for nearest mapping point below originalOffset
    - Returns shifted position accounting for all prior insertions

    mapClausePositions(clauses, offsetMap) -> clauseOverlays[]
    - Maps array of {startPosition, endPosition, clauseId, ...} to markdown positions
    - Returns ClauseOverlay[] with both original and markdown positions
    - Handles edge cases: overlapping clauses, out-of-range positions

    Test cases:
    - Empty text -> empty markdown, empty offsetMap
    - Text with no sections -> markdown === rawText, no shifts
    - Single heading -> prefix added, downstream text shifted
    - Multiple headings -> cumulative offset tracking
    - Clause spanning a heading insertion -> positions adjusted correctly
    - Out-of-range clause position -> clamped to document bounds
    - splitIntoParagraphs -> splits on double newline, tracks paragraph offsets
  </behavior>
  <implementation>
    1. RED: Write tests for convertToMarkdown with various section configurations
    2. RED: Write tests for translateOffset with edge cases
    3. RED: Write tests for mapClausePositions
    4. GREEN: Implement types.ts with all rendering interfaces
    5. GREEN: Implement text-to-markdown.ts (convertToMarkdown, splitIntoParagraphs)
    6. GREEN: Implement offset-mapper.ts (translateOffset, mapClausePositions)
    7. REFACTOR: Optimize binary search in translateOffset if needed
  </implementation>
</feature>

<tasks>

<task type="auto">
  <name>Task 1: Create types and implement TDD for conversion utilities</name>
  <files>
    lib/document-rendering/types.ts
    lib/document-rendering/text-to-markdown.ts
    lib/document-rendering/text-to-markdown.test.ts
    lib/document-rendering/offset-mapper.ts
    lib/document-rendering/offset-mapper.test.ts
  </files>
  <action>
    Create `lib/document-rendering/types.ts` with these interfaces:
    - `OffsetMapping { original: number; markdown: number }` - single offset translation point
    - `MarkdownConversion { markdown: string; offsetMap: OffsetMapping[] }` - conversion result
    - `DocumentSegment { text: string; startOffset: number; endOffset: number; index: number }` - paragraph segment for virtualization
    - `ClauseOverlay { clauseId: string; category: string; riskLevel: string; confidence: number; originalStart: number; originalEnd: number; markdownStart: number; markdownEnd: number; paragraphIndex: number }` - clause position in both coordinate systems
    - `PositionedSection { title: string; level: number; startOffset: number }` - section from DocumentStructure with position

    Import `PositionedSection` type from the existing DocumentStructure pattern in `lib/document-processing.ts` (check the Section/DocumentStructure types there and align).

    Write failing tests FIRST in text-to-markdown.test.ts:
    - Empty text returns empty markdown and empty offsetMap
    - Text with no sections returns identical markdown
    - Single h1 heading at position 0 adds "# " prefix (2 chars shift)
    - Multiple headings at different levels add correct prefixes with cumulative shifts
    - splitIntoParagraphs splits on "\n\n" and tracks paragraph start offsets correctly
    - Paragraph containing a heading gets the heading prefix in the correct segment

    Write failing tests in offset-mapper.test.ts:
    - translateOffset with empty offsetMap returns same position
    - translateOffset with single mapping shifts correctly
    - translateOffset before first mapping returns unshifted
    - mapClausePositions maps array of clauses through offsetMap
    - mapClausePositions handles zero-length clause (start === end)
    - mapClausePositions clamps out-of-range positions

    Then implement to make tests pass. Use `DocumentStructure` section type from existing codebase.
    Do NOT create barrel exports. Import directly from each file.
  </action>
  <verify>
    Follow RED-GREEN-REFACTOR cycle:
    1. RED: Write all tests first, run `pnpm test lib/document-rendering/` -- all tests MUST FAIL (no implementation yet)
    2. GREEN: Implement types.ts, text-to-markdown.ts, offset-mapper.ts -- run `pnpm test lib/document-rendering/` -- all tests MUST PASS
    3. REFACTOR (if needed): Clean up implementation, run `pnpm test lib/document-rendering/` -- tests MUST STILL PASS
  </verify>
  <done>All tests pass. convertToMarkdown correctly inserts heading prefixes and tracks offset shifts. translateOffset accurately maps original character positions to markdown positions. splitIntoParagraphs produces correctly bounded segments.</done>
</task>

<task type="auto">
  <name>Task 2: Add getDocumentForRendering server action</name>
  <files>
    app/(main)/(dashboard)/analyses/actions.ts
  </files>
  <action>
    Add a new server action `getDocumentForRendering` to the existing analyses/actions.ts file. This action:

    1. Takes `analysisId: string` parameter
    2. Calls `withTenant()` for auth + tenant isolation
    3. Fetches the analysis record (validates it exists and belongs to tenant)
    4. Fetches the document via `analysis.documentId` to get rawText, title, metadata
    5. Fetches clauseExtractions for this analysis, ordered by startPosition, selecting: id, category, riskLevel, startPosition, endPosition, confidence, clauseText, riskExplanation
    6. Parses DocumentStructure from document metadata (with safe fallback)
    7. Returns `ApiResponse<DocumentRenderingData>` with:
       - document: { rawText, title, metadata (including pageCount, uploadDate) }
       - structure: DocumentStructure (sections array)
       - clauses: Array of clause data with positions
       - status: analysis status string
       - tokenUsage: analysis.tokenUsage JSONB (total input/output tokens, estimatedCost) -- may be null if analysis is still running (used by Plan 11-08 for OUT-05 display)

    Export the `DocumentRenderingData` type for use by the document viewer component.

    IMPORTANT: This action returns RAW data (rawText, structure sections, clause positions). The markdown conversion (`convertToMarkdown`) and clause position mapping (`mapClausePositions`) happen CLIENT-SIDE in Plan 11-05's analysis page component. The server action does NOT perform markdown conversion -- it returns the raw inputs for it.

    Follow existing patterns in the file (use `ok()` / `err()` helpers, match the style of `getAnalysis` and `fetchRiskAssessments`).

    Also export the existing `riskConfig` type info (or define a `RiskLevelInfo` type) so the document renderer can import risk colors without duplicating the config object.
  </action>
  <verify>pnpm build (type-check passes)</verify>
  <done>getDocumentForRendering action exists, is type-safe, uses withTenant for tenant isolation, returns document rawText + structure + clauses with positions. Build passes.</done>
</task>

</tasks>

<verification>
- `pnpm test lib/document-rendering/` passes all tests
- `pnpm build` succeeds (no type errors)
- convertToMarkdown produces correct markdown with heading prefixes
- translateOffset handles all edge cases (empty map, single mapping, multiple mappings)
- mapClausePositions correctly translates clause arrays
- getDocumentForRendering returns all data needed for rendering
</verification>

<success_criteria>
- Text-to-markdown conversion handles all section heading levels with correct offset tracking
- Offset mapper accurately translates character positions through the markdown transformation
- Server action provides a single fetch for all document rendering data
- All utilities have comprehensive test coverage
</success_criteria>

<output>
After completion, create `.planning/phases/11-document-rendering/11-01-SUMMARY.md`
</output>
