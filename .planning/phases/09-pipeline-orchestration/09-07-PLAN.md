---
phase: 09-pipeline-orchestration
plan: 07
type: execute
wave: 4
depends_on: ["09-03", "09-04", "09-05"]
files_modified:
  - components/debug/pipeline-debug-panel.tsx
  - components/debug/step-timeline.tsx
  - app/(main)/(dashboard)/analyses/actions.ts
autonomous: true

must_haves:
  truths:
    - "Debug panel shows pipeline step status, timings, and raw AI output"
    - "Debug panel accessible for dev mode testing"
    - "Step timeline visualizes completed, running, pending, and failed states"
    - "Token usage breakdown visible per agent step"
  artifacts:
    - path: "components/debug/pipeline-debug-panel.tsx"
      provides: "Main debug panel component with step details"
      contains: "PipelineDebugPanel"
    - path: "components/debug/step-timeline.tsx"
      provides: "Visual timeline of pipeline steps"
      contains: "StepTimeline"
    - path: "app/(main)/(dashboard)/analyses/actions.ts"
      provides: "getDebugInfo action returning pipeline metadata"
      contains: "getDebugInfo"
  key_links:
    - from: "components/debug/pipeline-debug-panel.tsx"
      to: "app/(main)/(dashboard)/analyses/actions.ts"
      via: "Fetches debug info via getDebugInfo server action"
      pattern: "getDebugInfo"
    - from: "components/debug/pipeline-debug-panel.tsx"
      to: "components/debug/step-timeline.tsx"
      via: "Renders step timeline within the panel"
      pattern: "StepTimeline"
---

<objective>
Build a debug panel showing pipeline step timings, status, token usage, and raw AI output for developer testing.

Purpose: Developers need visibility into pipeline internals -- which steps completed, how long each took, how many tokens were used, and what the AI produced. This replaces context-switching to the Inngest dashboard for common debugging tasks.
Output: Debug panel component with step timeline, token usage breakdown, and expandable raw output sections.
</objective>

<execution_context>
@/Users/medelman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medelman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-pipeline-orchestration/09-RESEARCH.md
@components/artifact/analysis-view.tsx
@db/schema/analyses.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add getDebugInfo action and define debug types</name>
  <files>app/(main)/(dashboard)/analyses/actions.ts</files>
  <action>
  Add types and a server action for debug panel data.

  **Add types at the top of the file:**

  ```typescript
  /** Pipeline step status for debug panel */
  export interface PipelineStepInfo {
    name: string
    status: 'completed' | 'running' | 'pending' | 'failed' | 'skipped' | 'cancelled'
    durationMs?: number
    error?: string
  }

  /** Debug info for the pipeline */
  export interface PipelineDebugInfo {
    analysisId: string
    status: AnalysisStatus
    steps: PipelineStepInfo[]
    totalDurationMs: number | null
    tokenUsage: {
      total: { input: number; output: number; estimatedCost: number }
    } | null
    progressStage: string | null
    progressMessage: string | null
    progressPercent: number
    metadata: Record<string, unknown> | null
    chunkStats: Record<string, unknown> | null
    wasTruncated: boolean
    estimatedTokens: number | null
    actualTokens: number | null
  }
  ```

  **Add getDebugInfo action:**

  ```typescript
  /**
   * Get pipeline debug information for an analysis.
   *
   * Returns detailed pipeline state including step timings, token usage,
   * and metadata for the debug panel. Reads from the analyses table
   * metadata and status columns.
   *
   * @param analysisId - UUID of the analysis
   * @returns Pipeline debug information
   */
  export async function getDebugInfo(
    analysisId: string
  ): Promise<ApiResponse<PipelineDebugInfo>> {
    if (!z.string().uuid().safeParse(analysisId).success) {
      return err("VALIDATION_ERROR", "Invalid analysis ID");
    }

    const { db, tenantId } = await withTenant();

    const analysis = await db.query.analyses.findFirst({
      where: and(
        eq(analyses.id, analysisId),
        eq(analyses.tenantId, tenantId)
      ),
    });

    if (!analysis) {
      return err("NOT_FOUND", "Analysis not found");
    }

    // Derive step statuses from analysis state
    const currentStage = analysis.progressStage ?? ''
    const status = analysis.status as AnalysisStatus

    const stageOrder = ['parsing', 'chunking', 'classifying', 'scoring', 'analyzing_gaps', 'complete']

    const currentStageIndex = stageOrder.indexOf(currentStage)
    const isTerminal = ['completed', 'failed', 'cancelled'].includes(status)

    const steps: PipelineStepInfo[] = stageOrder
      .filter(s => s !== 'complete') // 'complete' is not a real step
      .map((stageName, index) => {
        let stepStatus: PipelineStepInfo['status']

        if (isTerminal && status === 'completed') {
          stepStatus = 'completed'
        } else if (isTerminal && status === 'cancelled') {
          stepStatus = index < currentStageIndex ? 'completed' : index === currentStageIndex ? 'cancelled' : 'skipped'
        } else if (isTerminal && status === 'failed') {
          stepStatus = index < currentStageIndex ? 'completed' : index === currentStageIndex ? 'failed' : 'skipped'
        } else if (index < currentStageIndex) {
          stepStatus = 'completed'
        } else if (index === currentStageIndex) {
          stepStatus = 'running'
        } else {
          stepStatus = 'pending'
        }

        return {
          name: stageName.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase()),
          status: stepStatus,
        }
      })

    // Parse token usage from JSONB
    const tokenUsage = analysis.tokenUsage as { total?: { input?: number; output?: number; estimatedCost?: number } } | null

    const debugInfo: PipelineDebugInfo = {
      analysisId: analysis.id,
      status: status,
      steps,
      totalDurationMs: analysis.processingTimeMs,
      tokenUsage: tokenUsage?.total ? {
        total: {
          input: tokenUsage.total.input ?? 0,
          output: tokenUsage.total.output ?? 0,
          estimatedCost: tokenUsage.total.estimatedCost ?? 0,
        },
      } : null,
      progressStage: analysis.progressStage,
      progressMessage: analysis.progressMessage,
      progressPercent: analysis.progressPercent ?? 0,
      metadata: analysis.metadata as Record<string, unknown> | null,
      chunkStats: analysis.chunkStats as Record<string, unknown> | null,
      wasTruncated: analysis.wasTruncated ?? false,
      estimatedTokens: analysis.estimatedTokens,
      actualTokens: analysis.actualTokens,
    }

    return ok(debugInfo);
  }
  ```
  </action>
  <verify>Run `pnpm lint`. Verify the action returns the PipelineDebugInfo type with step statuses derived from analysis state.</verify>
  <done>getDebugInfo action exists with pipeline step derivation, token usage parsing, and full metadata exposure for the debug panel.</done>
</task>

<task type="auto">
  <name>Task 2: Create debug panel components</name>
  <files>components/debug/pipeline-debug-panel.tsx, components/debug/step-timeline.tsx</files>
  <action>
  **IMPORTANT: Do NOT create an index.ts barrel export in components/debug/.**
  Barrel exports in component directories can cause production crashes by pulling in
  the entire module graph. Import each component directly by its file path instead:
  `import { PipelineDebugPanel } from "@/components/debug/pipeline-debug-panel"`
  See CLAUDE.md "Barrel Exports" section and Issue #43 for full context.

  **Create `components/debug/step-timeline.tsx`:**

  A visual timeline showing pipeline steps with their status:

  ```tsx
  "use client"

  import { cn } from "@/lib/utils"
  import type { PipelineStepInfo } from "@/app/(main)/(dashboard)/analyses/actions"

  const statusColors: Record<PipelineStepInfo['status'], string> = {
    completed: 'bg-green-500',
    running: 'bg-blue-500 animate-pulse',
    pending: 'bg-muted',
    failed: 'bg-red-500',
    skipped: 'bg-muted/50',
    cancelled: 'bg-yellow-500',
  }

  const statusLabels: Record<PipelineStepInfo['status'], string> = {
    completed: 'Done',
    running: 'Running',
    pending: 'Pending',
    failed: 'Failed',
    skipped: 'Skipped',
    cancelled: 'Cancelled',
  }

  interface StepTimelineProps {
    steps: PipelineStepInfo[]
  }

  export function StepTimeline({ steps }: StepTimelineProps) {
    return (
      <div className="space-y-2">
        {steps.map((step, index) => (
          <div key={step.name} className="flex items-center gap-3">
            {/* Status dot */}
            <div className={cn(
              "h-3 w-3 rounded-full shrink-0",
              statusColors[step.status]
            )} />

            {/* Connector line */}
            {index < steps.length - 1 && (
              <div className="absolute ml-1.5 mt-6 h-4 w-px bg-border" />
            )}

            {/* Step info */}
            <div className="flex-1 flex items-center justify-between min-w-0">
              <span className={cn(
                "text-sm font-medium",
                step.status === 'skipped' && "text-muted-foreground"
              )}>
                {step.name}
              </span>
              <span className={cn(
                "text-xs",
                step.status === 'failed' ? "text-red-500" :
                step.status === 'running' ? "text-blue-500" :
                "text-muted-foreground"
              )}>
                {statusLabels[step.status]}
                {step.durationMs != null && ` (${(step.durationMs / 1000).toFixed(1)}s)`}
              </span>
            </div>
          </div>
        ))}
      </div>
    )
  }
  ```

  **Create `components/debug/pipeline-debug-panel.tsx`:**

  The main debug panel that shows step timeline, token usage, and metadata:

  ```tsx
  "use client"

  import { useState, useEffect, useCallback } from "react"
  import { StepTimeline } from "./step-timeline"
  import { getDebugInfo } from "@/app/(main)/(dashboard)/analyses/actions"
  import type { PipelineDebugInfo } from "@/app/(main)/(dashboard)/analyses/actions"
  import { cn } from "@/lib/utils"

  interface PipelineDebugPanelProps {
    analysisId: string
    className?: string
  }

  export function PipelineDebugPanel({ analysisId, className }: PipelineDebugPanelProps) {
    const [debugInfo, setDebugInfo] = useState<PipelineDebugInfo | null>(null)
    const [error, setError] = useState<string | null>(null)
    const [expanded, setExpanded] = useState<Record<string, boolean>>({})

    const fetchDebug = useCallback(async () => {
      const result = await getDebugInfo(analysisId)
      if (result.success) {
        setDebugInfo(result.data)
        setError(null)
      } else {
        setError(result.error.message)
      }
    }, [analysisId])

    useEffect(() => {
      fetchDebug()

      // Poll while not terminal
      const interval = setInterval(async () => {
        const result = await getDebugInfo(analysisId)
        if (result.success) {
          setDebugInfo(result.data)
          if (['completed', 'failed', 'cancelled'].includes(result.data.status)) {
            clearInterval(interval)
          }
        }
      }, 3000)

      return () => clearInterval(interval)
    }, [analysisId, fetchDebug])

    if (error) return <div className="text-red-500 text-sm p-4">{error}</div>
    if (!debugInfo) return <div className="text-muted-foreground text-sm p-4">Loading debug info...</div>

    const toggleSection = (key: string) => {
      setExpanded(prev => ({ ...prev, [key]: !prev[key] }))
    }

    return (
      <div className={cn("space-y-4 font-mono text-xs", className)}>
        {/* Header */}
        <div className="flex items-center justify-between">
          <h3 className="text-sm font-semibold">Pipeline Debug</h3>
          <span className={cn(
            "px-2 py-0.5 rounded text-xs font-medium",
            debugInfo.status === 'completed' ? "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200" :
            debugInfo.status === 'failed' ? "bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200" :
            debugInfo.status === 'cancelled' ? "bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200" :
            "bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200"
          )}>
            {debugInfo.status}
          </span>
        </div>

        {/* Progress */}
        {debugInfo.progressMessage && (
          <div className="text-muted-foreground">
            {debugInfo.progressMessage} ({debugInfo.progressPercent}%)
          </div>
        )}

        {/* Step Timeline */}
        <div>
          <h4 className="text-xs font-semibold mb-2 text-muted-foreground uppercase tracking-wider">Steps</h4>
          <StepTimeline steps={debugInfo.steps} />
        </div>

        {/* Token Usage */}
        {debugInfo.tokenUsage && (
          <div>
            <h4 className="text-xs font-semibold mb-2 text-muted-foreground uppercase tracking-wider">Token Usage</h4>
            <div className="grid grid-cols-3 gap-2">
              <div>
                <div className="text-muted-foreground">Input</div>
                <div className="font-medium">{debugInfo.tokenUsage.total.input.toLocaleString()}</div>
              </div>
              <div>
                <div className="text-muted-foreground">Output</div>
                <div className="font-medium">{debugInfo.tokenUsage.total.output.toLocaleString()}</div>
              </div>
              <div>
                <div className="text-muted-foreground">Cost</div>
                <div className="font-medium">${debugInfo.tokenUsage.total.estimatedCost.toFixed(4)}</div>
              </div>
            </div>
          </div>
        )}

        {/* Processing Time */}
        {debugInfo.totalDurationMs != null && (
          <div>
            <span className="text-muted-foreground">Total time: </span>
            <span className="font-medium">{(debugInfo.totalDurationMs / 1000).toFixed(1)}s</span>
          </div>
        )}

        {/* Budget Info */}
        <div className="flex gap-4">
          {debugInfo.estimatedTokens != null && (
            <div>
              <span className="text-muted-foreground">Est. tokens: </span>
              <span>{debugInfo.estimatedTokens.toLocaleString()}</span>
            </div>
          )}
          {debugInfo.actualTokens != null && (
            <div>
              <span className="text-muted-foreground">Actual: </span>
              <span>{debugInfo.actualTokens.toLocaleString()}</span>
            </div>
          )}
          {debugInfo.wasTruncated && (
            <span className="text-yellow-600">Truncated</span>
          )}
        </div>

        {/* Chunk Stats (collapsible) */}
        {debugInfo.chunkStats && (
          <div>
            <button
              onClick={() => toggleSection('chunkStats')}
              className="text-xs font-semibold text-muted-foreground uppercase tracking-wider hover:text-foreground"
            >
              {expanded.chunkStats ? '- ' : '+ '}Chunk Stats
            </button>
            {expanded.chunkStats && (
              <pre className="mt-1 p-2 bg-muted rounded text-xs overflow-x-auto max-h-40">
                {JSON.stringify(debugInfo.chunkStats, null, 2)}
              </pre>
            )}
          </div>
        )}

        {/* Metadata (collapsible) */}
        {debugInfo.metadata && Object.keys(debugInfo.metadata).length > 0 && (
          <div>
            <button
              onClick={() => toggleSection('metadata')}
              className="text-xs font-semibold text-muted-foreground uppercase tracking-wider hover:text-foreground"
            >
              {expanded.metadata ? '- ' : '+ '}Raw Metadata
            </button>
            {expanded.metadata && (
              <pre className="mt-1 p-2 bg-muted rounded text-xs overflow-x-auto max-h-60">
                {JSON.stringify(debugInfo.metadata, null, 2)}
              </pre>
            )}
          </div>
        )}
      </div>
    )
  }
  ```

  Use the existing patterns from the codebase: `cn()` for class merging, `text-muted-foreground` for labels, `bg-muted` for code blocks. The panel should feel like a lightweight Inngest dashboard tab embedded in the app.

  These components are dev/admin tools, so they don't need the full shadcn component treatment. Simple Tailwind styling is appropriate.
  </action>
  <verify>Run `pnpm lint`. Verify both components compile and export correctly. Check that the debug panel polls for updates and stops when terminal. Verify NO index.ts barrel file exists in components/debug/.</verify>
  <done>Debug panel with step timeline, token usage breakdown, processing time, chunk stats, and collapsible metadata sections. Auto-polls during processing, stops when terminal. No barrel export in components/debug/.</done>
</task>

</tasks>

<verification>
1. `pnpm lint` passes
2. PipelineDebugPanel component exists and is importable via direct path
3. StepTimeline component renders step statuses visually
4. getDebugInfo action returns pipeline metadata
5. Panel auto-refreshes during active processing
6. No index.ts barrel export exists in components/debug/
</verification>

<success_criteria>
- Debug panel shows step statuses (completed/running/pending/failed/cancelled)
- Token usage breakdown visible (input/output/cost)
- Processing time displayed
- Chunk stats and raw metadata expandable
- Polling stops on terminal states
- No barrel export in components/debug/ directory
</success_criteria>

<output>
After completion, create `.planning/phases/09-pipeline-orchestration/09-07-SUMMARY.md`
</output>
