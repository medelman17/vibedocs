---
phase: 09-pipeline-orchestration
plan: 04
type: execute
wave: 3
depends_on: ["09-01", "09-03"]
files_modified:
  - inngest/functions/analyze-nda.ts
autonomous: true

must_haves:
  truths:
    - "Risk scorer runs as per-batch Inngest steps, not a single monolithic step"
    - "Clause-level progress visible: 'Scoring clause 7 of 15...'"
    - "Each risk scorer batch is independently retriable on failure"
    - "Rate limit delays between risk scorer batches for Claude"
  artifacts:
    - path: "inngest/functions/analyze-nda.ts"
      provides: "Per-batch risk scorer steps with clause-level progress"
      contains: "score-batch-"
  key_links:
    - from: "inngest/functions/analyze-nda.ts"
      to: "agents/risk-scorer.ts"
      via: "Per-batch calls to risk scorer with subset of clauses"
      pattern: "score-batch"
---

<objective>
Split risk scorer into per-batch Inngest steps for clause-level progress and independent retry.

Purpose: Currently the risk scorer runs as a single monolithic step.run() call. This prevents showing "Scoring clause 7 of 15..." progress and means a failure 90% through the step loses all work. Splitting into per-batch steps gives granular progress updates and makes each batch independently retriable.
Output: analyze-nda.ts with per-batch risk scorer steps and clause-level progress emissions between batches.
</objective>

<execution_context>
@/Users/medelman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medelman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-pipeline-orchestration/09-RESEARCH.md
@.planning/phases/09-pipeline-orchestration/09-01-PLAN.md
@.planning/phases/09-pipeline-orchestration/09-03-PLAN.md
@inngest/functions/analyze-nda.ts
@agents/risk-scorer.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Split risk scorer into per-batch Inngest steps</name>
  <files>inngest/functions/analyze-nda.ts</files>
  <action>
  Apply the per-batch pattern (same approach as 09-03 did for the classifier) to the risk scorer in both `analyzeNda` and `analyzeNdaAfterOcr`.

  The risk scorer processes individual clauses (not chunks). After classification, we have `classifierResult.clauses` -- typically 5-15 clauses. Score them in batches of 3-5:

  ```typescript
  // Step 9: Risk Scorer Agent (per-batch for clause-level progress)
  const SCORER_BATCH_SIZE = 3
  const clausesToScore = classifierResult.clauses
  const totalScorerBatches = Math.ceil(clausesToScore.length / SCORER_BATCH_SIZE)

  let allAssessments: typeof riskResult.assessments = []
  let lastRiskResult: typeof riskResult | null = null

  for (let batch = 0; batch < totalScorerBatches; batch++) {
    const batchStart = batch * SCORER_BATCH_SIZE
    const batchEnd = Math.min(batchStart + SCORER_BATCH_SIZE, clausesToScore.length)
    const batchClauses = clausesToScore.slice(batchStart, batchEnd)

    const batchResult = await step.run(`score-batch-${batch}`, () =>
      runRiskScorerAgent({
        clauses: batchClauses,
        budgetTracker,
        perspective: 'balanced',
      })
    )

    allAssessments.push(...batchResult.assessments)
    lastRiskResult = batchResult

    // Clause-level progress
    const scored = Math.min(batchEnd, clausesToScore.length)
    await emitProgress(
      'scoring',
      60 + Math.round((scored / clausesToScore.length) * 20), // 60-80% range
      `Scoring clause ${scored} of ${clausesToScore.length}...`
    )

    // Rate limit between batches (Claude 60 RPM)
    if (batch < totalScorerBatches - 1) {
      await step.sleep(`rate-limit-score-${batch}`, getRateLimitDelay('claude'))
    }
  }

  // Assemble final risk result
  const riskResult = {
    assessments: allAssessments,
    overallRiskScore: lastRiskResult!.overallRiskScore,
    overallRiskLevel: lastRiskResult!.overallRiskLevel,
    executiveSummary: lastRiskResult!.executiveSummary,
    perspective: lastRiskResult!.perspective,
    riskDistribution: lastRiskResult!.riskDistribution,
  }
  ```

  **Note:** The executive summary and overall scores from `lastRiskResult` will only reflect the last batch's subset. This is a known tradeoff. The overall risk score gets recalculated via `calculateWeightedRisk` in the persist-final step anyway, and the executive summary was already being populated in the scoring loop. For accuracy of the executive summary across all clauses, we can generate it separately after all batches complete, or accept the last batch's summary as a reasonable approximation. Given that the risk scorer's executive summary considers the full set of clauses it receives, and the last batch only sees a subset, we should generate a final summary step.

  **Simpler approach:** After all batches, recalculate `overallRiskScore` and `overallRiskLevel` from allAssessments (these are already recalculated via `calculateWeightedRisk` in persist-final). For the executive summary, we already have one from `lastRiskResult`. This is acceptable for MVP since the executive summary from any batch gives reasonable context.

  Remove the old single `step.run('risk-scorer-agent', ...)` and its emitProgress call.

  Apply the same pattern to `analyzeNdaAfterOcr`.

  **Also update the persist-classifications step** to use the new `classifierResult` variable (which was assembled from batches in 09-03, not a single call result). The structure should be identical since we pushed all raw classifications and clauses into arrays.

  Remove the old single-call `emitProgress('scoring', ...)` after the old risk scorer step.
  </action>
  <verify>Run `pnpm lint`. Grep for `score-batch-` to confirm per-batch step IDs. Verify no remaining `step.run('risk-scorer-agent'` (old monolithic step). Verify the persist-classifications step still works with the batched classifierResult.</verify>
  <done>Risk scorer runs as per-batch steps with "Scoring clause 7 of 15..." progress, each batch independently retriable, rate limits respected between batches, persist-final uses accumulated assessments.</done>
</task>

</tasks>

<verification>
1. `pnpm lint` passes
2. Grep for `score-batch-` in analyze-nda.ts returns matches for both functions
3. No remaining `step.run('risk-scorer-agent'` (old monolithic step)
4. emitProgress calls show clause-level messages with counts
</verification>

<success_criteria>
- Risk scorer uses per-batch steps: `score-batch-0`, `score-batch-1`, etc.
- Progress messages show "Scoring clause X of Y..."
- Rate limit sleeps between risk scorer batches
- Both analyzeNda and analyzeNdaAfterOcr updated consistently
</success_criteria>

<output>
After completion, create `.planning/phases/09-pipeline-orchestration/09-04-SUMMARY.md`
</output>
