---
phase: 09-pipeline-orchestration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - inngest/functions/cleanup-cancelled.ts
  - inngest/functions/index.ts
  - app/(main)/(dashboard)/analyses/actions.ts
  - hooks/use-analysis-progress.ts
autonomous: true

must_haves:
  truths:
    - "When a pipeline is cancelled via event, analysis status becomes 'cancelled' (not 'failed')"
    - "User can cancel an in-progress analysis and the Inngest pipeline stops"
    - "User can resume a cancelled or failed analysis from where it stopped"
    - "Progress polling stops when status is 'cancelled' (treated as terminal)"
  artifacts:
    - path: "inngest/functions/cleanup-cancelled.ts"
      provides: "Cancellation cleanup handler triggered by inngest/function.cancelled"
      contains: "inngest/function.cancelled"
    - path: "inngest/functions/index.ts"
      provides: "cleanup function registered in function registry"
      contains: "cleanupCancelledAnalysis"
    - path: "app/(main)/(dashboard)/analyses/actions.ts"
      provides: "Updated cancelAnalysis with event emission, new resumeAnalysis action"
      contains: "resumeAnalysis"
  key_links:
    - from: "app/(main)/(dashboard)/analyses/actions.ts"
      to: "inngest/functions/cleanup-cancelled.ts"
      via: "cancelAnalysis sends nda/analysis.cancelled event -> triggers cancelOn -> inngest/function.cancelled -> cleanup handler"
      pattern: "nda/analysis.cancelled"
    - from: "inngest/functions/cleanup-cancelled.ts"
      to: "db/schema/analyses.ts"
      via: "Sets status to cancelled in DB"
      pattern: "status.*cancelled"
---

<objective>
Create cancellation cleanup handler, update cancel/resume server actions, and extend progress polling for cancelled status.

Purpose: Complete the cancellation flow end-to-end: user clicks cancel -> event fires -> pipeline stops -> cleanup handler updates DB -> UI reflects cancelled state. Also adds resume capability so users can pick up where they left off.
Output: Cleanup Inngest function, updated cancelAnalysis action (event-based), new resumeAnalysis action, progress hook handles cancelled status.
</objective>

<execution_context>
@/Users/medelman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medelman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-pipeline-orchestration/09-RESEARCH.md
@inngest/functions/index.ts
@inngest/types.ts
@app/(main)/(dashboard)/analyses/actions.ts
@hooks/use-analysis-progress.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create cancellation cleanup handler</name>
  <files>inngest/functions/cleanup-cancelled.ts, inngest/functions/index.ts</files>
  <action>
  Create `inngest/functions/cleanup-cancelled.ts`:

  This function listens for the `inngest/function.cancelled` system event, which fires whenever an Inngest function is cancelled via `cancelOn`. It updates the analysis status to 'cancelled' in the DB.

  ```typescript
  /**
   * @fileoverview Cancellation Cleanup Handler
   *
   * Listens for inngest/function.cancelled system events and updates
   * the analysis status to 'cancelled' in the database. This ensures
   * consistency between Inngest pipeline state and DB state.
   *
   * This function is intentionally lightweight -- it only imports drizzle
   * (no agents, no PDF processing) to avoid barrel export issues.
   *
   * @module inngest/functions/cleanup-cancelled
   */

  import { inngest, RETRY_CONFIG, withTenantContext } from '@/inngest'
  import { analyses } from '@/db/schema/analyses'
  import { eq } from 'drizzle-orm'
  import { sql } from 'drizzle-orm'

  export const cleanupCancelledAnalysis = inngest.createFunction(
    {
      id: 'cleanup-cancelled-analysis',
      name: 'Cleanup After Cancelled Analysis',
      retries: RETRY_CONFIG.nonCritical.retries,
    },
    { event: 'inngest/function.cancelled' },
    async ({ event, step }) => {
      // Only handle cancellations of the analysis pipeline functions
      const functionId = event.data.function_id
      if (functionId !== 'analyze-nda' && functionId !== 'analyze-nda-after-ocr') {
        return { skipped: true, reason: `Not an analysis function: ${functionId}` }
      }

      // Extract data from the original triggering event
      const originalEvent = event.data.event
      const analysisId = originalEvent?.data?.analysisId
      const tenantId = originalEvent?.data?.tenantId

      if (!analysisId || !tenantId) {
        return { skipped: true, reason: 'Missing analysisId or tenantId in original event' }
      }

      await step.run('mark-cancelled', async () => {
        await withTenantContext(tenantId, async (ctx) => {
          await ctx.db
            .update(analyses)
            .set({
              status: 'cancelled',
              progressStage: 'cancelled',
              progressMessage: 'Analysis cancelled by user',
              updatedAt: new Date(),
              metadata: sql`COALESCE(metadata, '{}'::jsonb) || ${JSON.stringify({
                cancelledAt: new Date().toISOString(),
              })}::jsonb`,
            })
            .where(eq(analyses.id, analysisId))
        })
      })

      return { analysisId, cancelled: true }
    }
  )
  ```

  Note the `inngest/function.cancelled` event type. Inngest fires this automatically as a system event when a function is cancelled via `cancelOn`. The event shape has `data.function_id` (the cancelled function's ID) and `data.event` (the original triggering event's full payload).

  **IMPORTANT:** This function must NOT be added to the `InngestEvents` type map since `inngest/function.cancelled` is a system event, not a user-defined event. The Inngest client already knows about it.

  **Register in functions index:**

  In `inngest/functions/index.ts`, add the import and registration:
  ```typescript
  import { cleanupCancelledAnalysis } from './cleanup-cancelled'

  export const functions = [
    // ... existing entries ...
    cleanupCancelledAnalysis,
  ]
  ```
  </action>
  <verify>Run `pnpm lint` to confirm no type errors. Verify the cleanup function imports only lightweight dependencies (drizzle, inngest barrel -- no agents, no pdf-parse).</verify>
  <done>Cleanup handler created, registered in function index, handles only analyze-nda and analyze-nda-after-ocr cancellations, sets status to 'cancelled' with timestamp in metadata.</done>
</task>

<task type="auto">
  <name>Task 2: Update cancel action, add resume action, extend progress hook</name>
  <files>app/(main)/(dashboard)/analyses/actions.ts, hooks/use-analysis-progress.ts</files>
  <action>
  **Update cancelAnalysis in actions.ts:**

  Replace the current cancelAnalysis implementation. The key change: instead of directly setting status='failed', send the `nda/analysis.cancelled` event which triggers cancelOn in the pipeline. Also optimistically update status to 'cancelled' for immediate UI feedback:

  ```typescript
  export async function cancelAnalysis(
    analysisId: string
  ): Promise<ApiResponse<void>> {
    if (!z.string().uuid().safeParse(analysisId).success) {
      return err("VALIDATION_ERROR", "Invalid analysis ID");
    }

    const { db, tenantId } = await withTenant();

    const analysis = await db.query.analyses.findFirst({
      where: and(
        eq(analyses.id, analysisId),
        eq(analyses.tenantId, tenantId)
      ),
      columns: {
        id: true,
        status: true,
      },
    });

    if (!analysis) {
      return err("NOT_FOUND", "Analysis not found");
    }

    if (!["pending", "pending_ocr", "processing"].includes(analysis.status)) {
      return err(
        "CONFLICT",
        `Cannot cancel analysis with status: ${analysis.status}. Only pending or processing analyses can be cancelled.`
      );
    }

    // Send cancellation event (triggers cancelOn in analyze-nda / analyze-nda-after-ocr)
    await inngest.send({
      name: "nda/analysis.cancelled",
      data: {
        tenantId,
        analysisId,
        reason: "user_cancelled" as const,
      },
    });

    // Optimistically update status for immediate UI feedback
    // The cleanup handler will also update this (idempotent)
    await db
      .update(analyses)
      .set({
        status: "cancelled",
        progressStage: "cancelled",
        progressMessage: "Analysis cancelled by user",
        updatedAt: new Date(),
      })
      .where(eq(analyses.id, analysisId));

    revalidatePath("/dashboard");
    revalidatePath("/analyses");

    return ok(undefined);
  }
  ```

  Note: Also include `"pending_ocr"` in cancellable statuses since a document waiting for OCR should be cancellable too.

  **Add resumeAnalysis action:**

  Add after cancelAnalysis:

  ```typescript
  /**
   * Resume a cancelled or failed analysis from where it stopped.
   *
   * Inngest step memoization means completed steps replay instantly
   * and execution picks up at the first uncompleted step.
   *
   * @param analysisId - UUID of the analysis to resume
   * @returns The analysis record
   */
  export async function resumeAnalysis(
    analysisId: string
  ): Promise<ApiResponse<Analysis>> {
    if (!z.string().uuid().safeParse(analysisId).success) {
      return err("VALIDATION_ERROR", "Invalid analysis ID");
    }

    const { db, tenantId } = await withTenant();

    const analysis = await db.query.analyses.findFirst({
      where: and(
        eq(analyses.id, analysisId),
        eq(analyses.tenantId, tenantId)
      ),
      columns: {
        id: true,
        status: true,
        documentId: true,
      },
    });

    if (!analysis) {
      return err("NOT_FOUND", "Analysis not found");
    }

    if (!["cancelled", "failed"].includes(analysis.status)) {
      return err(
        "CONFLICT",
        `Cannot resume analysis with status: ${analysis.status}. Only cancelled or failed analyses can be resumed.`
      );
    }

    // Reset status to processing and re-trigger the pipeline
    // Inngest step memoization means completed steps return cached results instantly
    await db
      .update(analyses)
      .set({
        status: "processing",
        progressMessage: "Resuming analysis...",
        updatedAt: new Date(),
      })
      .where(eq(analyses.id, analysisId));

    // Re-send the analysis event -- Inngest will create a new run
    // but step.run() memoization means completed steps replay instantly
    await inngest.send({
      name: "nda/analysis.requested",
      data: {
        tenantId,
        documentId: analysis.documentId,
        analysisId: analysis.id,
        source: "web-upload" as const,
      },
    });

    // Fetch the updated record to return
    const updated = await db.query.analyses.findFirst({
      where: eq(analyses.id, analysisId),
    });

    revalidatePath("/dashboard");
    revalidatePath("/analyses");

    return ok(updated!);
  }
  ```

  **Update progress hook:**

  In `hooks/use-analysis-progress.ts`:

  1. Add `'cancelled'` to the terminal state check so polling stops:
     ```typescript
     if (
       result.data.status === "completed" ||
       result.data.status === "failed" ||
       result.data.status === "cancelled"
     ) {
     ```

  2. Add `message` to the AnalysisProgressState interface and populate it from the response:
     ```typescript
     interface AnalysisProgressState {
       status: AnalysisStatus
       progress: number
       stage: string
       message: string   // NEW: detailed progress message
       isLoading: boolean
       error: string | null
     }
     ```

     Initialize `message: ""` in default state and set it from the polling response. The `getAnalysisStatus` action already returns `step` which contains the stage message. For now, use that as the message since progressMessage is a DB column that will be populated by the emitProgress calls.
  </action>
  <verify>Run `pnpm lint` to confirm no type errors. Verify cancelAnalysis sends the Inngest event. Verify progress hook stops polling on 'cancelled' status.</verify>
  <done>cancelAnalysis sends nda/analysis.cancelled event and optimistically sets status, resumeAnalysis re-triggers pipeline for step memoization recovery, progress hook treats 'cancelled' as terminal state and exposes message field.</done>
</task>

</tasks>

<verification>
1. `pnpm lint` passes
2. Grep for `nda/analysis.cancelled` in actions.ts confirms event is sent
3. Grep for `resumeAnalysis` in actions.ts confirms new action exists
4. Grep for `cancelled` in use-analysis-progress.ts confirms terminal state handling
5. Grep for `cleanupCancelledAnalysis` in functions/index.ts confirms registration
</verification>

<success_criteria>
- Cancellation cleanup handler exists and is registered
- cancelAnalysis sends Inngest event (not just DB update)
- resumeAnalysis action exists and re-triggers pipeline
- Progress hook stops polling on 'cancelled' status
- All imports are lightweight (no heavy deps in cleanup handler)
</success_criteria>

<output>
After completion, create `.planning/phases/09-pipeline-orchestration/09-02-SUMMARY.md`
</output>
