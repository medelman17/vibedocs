---
phase: 10-progress-streaming
plan: 03
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - app/(main)/(dashboard)/analyses/actions.ts
  - hooks/use-analysis-progress.ts
autonomous: true

must_haves:
  truths:
    - "Web UI receives real-time progress without polling as primary transport"
    - "Polling is retained as degraded fallback at 5s interval"
    - "On connect, client fetches current state from DB (late join snapshot)"
    - "useAnalysisProgress hook interface is unchanged for consumers"
    - "Server action validates tenant ownership before generating token"
    - "Reconnection after disconnect resumes via token refresh + next published event (STR-04)"
  artifacts:
    - path: "app/(main)/(dashboard)/analyses/actions.ts"
      provides: "fetchRealtimeToken server action"
      exports: ["fetchRealtimeToken"]
    - path: "hooks/use-analysis-progress.ts"
      provides: "Refactored hook with Inngest Realtime primary + polling fallback"
      exports: ["useAnalysisProgress"]
  key_links:
    - from: "hooks/use-analysis-progress.ts"
      to: "@inngest/realtime/hooks"
      via: "useInngestSubscription"
      pattern: "useInngestSubscription"
    - from: "hooks/use-analysis-progress.ts"
      to: "app/(main)/(dashboard)/analyses/actions.ts"
      via: "fetchRealtimeToken server action"
      pattern: "fetchRealtimeToken"
    - from: "app/(main)/(dashboard)/analyses/actions.ts"
      to: "lib/realtime/tokens.ts"
      via: "generateAnalysisToken helper"
      pattern: "generateAnalysisToken"
---

<objective>
Add a server action for token generation and refactor the web UI hook to use Inngest Realtime as the primary transport with polling as fallback.

Purpose: Web UI shows live progress without polling. The hook interface is unchanged so no consumer code needs updating.
Output: Server action + refactored hook providing real-time progress to the web UI.
</objective>

<execution_context>
@/Users/medelman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medelman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-progress-streaming/10-RESEARCH.md
@.planning/phases/10-progress-streaming/10-CONTEXT.md
@.planning/phases/10-progress-streaming/10-01-SUMMARY.md

@app/(main)/(dashboard)/analyses/actions.ts
@hooks/use-analysis-progress.ts
@lib/realtime/tokens.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add fetchRealtimeToken server action</name>
  <files>app/(main)/(dashboard)/analyses/actions.ts</files>
  <action>
    Add a new server action `fetchRealtimeToken` to the existing actions file.

    1. Add imports at the top of the file:
       ```typescript
       import { generateAnalysisToken, type AnalysisToken } from "@/lib/realtime/tokens"
       ```

    2. Re-export the `AnalysisToken` type for client consumption:
       ```typescript
       export type { AnalysisToken }
       ```

    3. Add the server action at the end of the file (before the closing):
       ```typescript
       /**
        * Generate an Inngest Realtime subscription token for analysis progress.
        *
        * Validates tenant ownership before generating a scoped token.
        * Used by the useAnalysisProgress hook for real-time streaming.
        *
        * @param analysisId - UUID of the analysis to subscribe to
        * @returns Scoped subscription token for the analysis progress channel
        */
       export async function fetchRealtimeToken(
         analysisId: string
       ): Promise<AnalysisToken> {
         const { db, tenantId } = await withTenant();

         // Verify analysis belongs to tenant
         const analysis = await db.query.analyses.findFirst({
           where: and(
             eq(analyses.id, analysisId),
             eq(analyses.tenantId, tenantId)
           ),
           columns: { id: true },
         });

         if (!analysis) {
           throw new Error("Analysis not found");
         }

         return generateAnalysisToken(analysisId);
       }
       ```

    Note: This throws on auth/not-found errors (not ApiResponse). Server actions used as token refreshers should throw — the `useInngestSubscription` hook handles errors internally.
  </action>
  <verify>
    - `pnpm build` succeeds
    - `fetchRealtimeToken` is exported from the actions file
    - Action calls `withTenant()` for auth and `generateAnalysisToken()` for token
  </verify>
  <done>
    Server action generates scoped Inngest Realtime tokens with tenant ownership validation
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor useAnalysisProgress hook for Inngest Realtime</name>
  <files>hooks/use-analysis-progress.ts</files>
  <action>
    Refactor the hook in-place to use Inngest Realtime as primary transport with polling fallback. The hook's public interface (return type `AnalysisProgressState`) MUST remain unchanged.

    1. Add imports:
       ```typescript
       import { useInngestSubscription } from "@inngest/realtime/hooks"
       import { fetchRealtimeToken } from "@/app/(main)/(dashboard)/analyses/actions"
       ```

    2. Keep existing imports for `getAnalysisStatus` (used by fallback polling).

    3. Change `POLL_INTERVAL_MS` from 2000 to 5000 (degraded fallback interval).

    4. Keep the `AnalysisProgressState` interface unchanged.

    5. Rewrite the hook body:

       a. **Initial state fetch** (late join snapshot per CONTEXT.md decision):
          - On mount (when analysisId is set), call `getAnalysisStatus(analysisId)` once to get current DB state
          - Set initial state from the response (stage, percent, message, queuePosition)
          - This ensures user immediately sees where analysis is, not blank

       b. **Inngest Realtime subscription** (primary transport):
          - Use `useInngestSubscription` with conditional `refreshToken`:
            ```typescript
            const isTerminal = ['completed', 'failed', 'cancelled'].includes(state.status)
            const subscription = useInngestSubscription({
              refreshToken: (analysisId && !isTerminal)
                ? () => fetchRealtimeToken(analysisId)
                : undefined,
            })
            ```
            Pass `undefined` for `refreshToken` to disable the subscription (when no analysisId or terminal state).
          - When `subscription.latestData?.data` changes, update state from the realtime event
          - Map realtime event fields to AnalysisProgressState (stage -> stage, percent -> progress, message -> message)
          - Detect terminal stages ("complete" -> status "completed", "failed" -> "failed") and stop

          **Reconnection handling (STR-04):** `useInngestSubscription` handles reconnection internally — when a connection drops, it calls `refreshToken` again to get a fresh subscription token and reconnects automatically. Because Inngest Realtime has at-most-once delivery, events during the disconnection gap may be missed. This is handled by the initial state fetch pattern: on reconnect, the hook gets a new token and resubscribes; the `latestData` will contain the next published event. Combined with the DB-based initial state fetch (step 5a), the client always has at least the last persisted state. If the gap between disconnect and reconnect exceeds the analysis duration, the polling fallback (step 5c) catches the terminal state.

       c. **Polling fallback** (degraded mode):
          - If `subscription.error` is set (Inngest Realtime connection failed), fall back to polling
          - Use the existing polling logic but at 5s interval
          - Use a `useRef` to track whether realtime is working to decide if polling should activate
          - If realtime delivers at least one event, disable polling

       d. **Combined state management**:
          - Realtime events take priority over polling when both are active
          - Initial state from DB is overwritten by first realtime or poll update
          - Terminal state stops both realtime subscription and polling

    6. The hook signature and return type MUST remain identical:
       ```typescript
       export function useAnalysisProgress(analysisId: string | null): AnalysisProgressState
       ```
       No breaking changes to consumers.

    IMPORTANT:
    - `useInngestSubscription` returns `{ data, error, latestData, state }` — use `latestData` for most recent event
    - Disable the subscription by passing `refreshToken: undefined` (the hook no-ops without a token fetcher)
    - Keep the `"use client"` directive at top of file
    - `queuePosition` comes from the initial DB fetch only (not from realtime events) — realtime events only carry stage/percent/message
    - Reconnection is handled internally by `useInngestSubscription` (re-calls refreshToken, resubscribes)
  </action>
  <verify>
    - `pnpm build` succeeds
    - `hooks/use-analysis-progress.ts` imports `useInngestSubscription`
    - Hook return type is still `AnalysisProgressState` (unchanged)
    - Hook still exports same function name `useAnalysisProgress`
    - Polling interval changed from 2000 to 5000
    - Initial state fetched from DB on mount
  </verify>
  <done>
    Web UI hook uses Inngest Realtime as primary transport with 5s polling fallback; interface unchanged; consumers need no updates
  </done>
</task>

</tasks>

<verification>
- `pnpm build` passes
- `pnpm lint` passes
- `fetchRealtimeToken` exported from analyses/actions.ts
- `useAnalysisProgress` hook interface unchanged (same params and return type)
- Hook imports `useInngestSubscription` from `@inngest/realtime/hooks`
- Polling fallback at 5s interval when realtime fails
- Initial state fetch from DB for late join
</verification>

<success_criteria>
Web UI shows live progress via Inngest Realtime. Polling degrades gracefully to 5s when realtime connection fails. Hook interface is unchanged — no consumer code updates needed.
</success_criteria>

<output>
After completion, create `.planning/phases/10-progress-streaming/10-03-SUMMARY.md`
</output>
