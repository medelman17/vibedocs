---
phase: 05-legal-chunking
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - lib/document-chunking/legal-chunker.ts
  - lib/document-chunking/chunk-strategies.ts
  - lib/document-chunking/chunk-merger.ts
  - lib/document-chunking/cross-reference.ts
  - lib/document-chunking/chunk-map.ts
  - lib/document-extraction/structure-detector.ts
autonomous: true

must_haves:
  truths:
    - "Definitions sections produce one chunk per definition term"
    - "Lettered sub-clauses (a), (b), (c) each become their own chunk"
    - "Chunks respect section boundaries (no split mid-clause)"
    - "No chunk exceeds 512 tokens (verified by Llama 2 tokenizer)"
    - "Short chunks under 50 tokens are merged with adjacent siblings"
    - "Cross-references annotated in metadata (e.g., references: ['3.1', '7.4'])"
    - "Chunk map summary generated per document with stats and entries"
    - "Boilerplate/signature chunks marked with chunkType 'boilerplate'"
    - "Unstructured documents fall back to paragraph-based splitting"
    - "Low chunk count or empty structure triggers LLM re-chunking via detectStructure({ forceLlm: true })"
  artifacts:
    - path: "lib/document-chunking/legal-chunker.ts"
      provides: "Main entry point chunkLegalDocument()"
      exports: ["chunkLegalDocument"]
    - path: "lib/document-chunking/chunk-strategies.ts"
      provides: "Strategy implementations for definitions, clauses, sub-clauses, recitals, boilerplate, exhibits, fallback"
      exports: ["chunkDefinitions", "chunkClause", "chunkBoilerplate", "chunkExhibit", "chunkRecital", "chunkFallback"]
    - path: "lib/document-chunking/chunk-merger.ts"
      provides: "Short chunk merging and oversized chunk splitting"
      exports: ["mergeShortChunks", "splitOversizedChunks"]
    - path: "lib/document-chunking/cross-reference.ts"
      provides: "Cross-reference extraction from legal text"
      exports: ["extractCrossReferences"]
    - path: "lib/document-chunking/chunk-map.ts"
      provides: "Chunk map summary generator"
      exports: ["generateChunkMap", "computeChunkStats"]
    - path: "lib/document-extraction/structure-detector.ts"
      provides: "detectStructure with forceLlm option for LLM re-chunking"
      exports: ["detectStructure"]
  key_links:
    - from: "lib/document-chunking/legal-chunker.ts"
      to: "lib/document-chunking/chunk-strategies.ts"
      via: "calls strategy functions based on section type"
      pattern: "chunkDefinitions|chunkClause|chunkBoilerplate"
    - from: "lib/document-chunking/legal-chunker.ts"
      to: "lib/document-chunking/chunk-merger.ts"
      via: "post-processes chunks for size compliance"
      pattern: "mergeShortChunks|splitOversizedChunks"
    - from: "lib/document-chunking/legal-chunker.ts"
      to: "lib/document-chunking/token-counter.ts"
      via: "counts tokens using Voyage AI tokenizer"
      pattern: "countVoyageTokensSync|countVoyageTokens"
    - from: "lib/document-chunking/legal-chunker.ts"
      to: "lib/document-extraction/structure-detector.ts"
      via: "calls detectStructure({ forceLlm: true }) when structure quality is poor"
      pattern: "detectStructure.*forceLlm"
    - from: "lib/document-chunking/chunk-strategies.ts"
      to: "lib/document-extraction/types.ts"
      via: "consumes PositionedSection from structure detector"
      pattern: "PositionedSection"
---

<objective>
Build the legal-aware document chunking engine that transforms extracted text + DocumentStructure into right-sized, metadata-rich chunks respecting legal document boundaries. Includes LLM re-chunking fallback when structure quality is poor.

Purpose: This is the core algorithmic work of Phase 5. It replaces the simplistic paragraph-based `chunkDocument()` with structure-aware chunking that produces granular, well-typed chunks suitable for RAG retrieval, classification, and risk scoring. The LLM re-chunking path (CHK-03) ensures even poorly-structured documents get quality chunks.

Output: Five chunking modules plus an update to structure-detector.ts for forceLlm support.
</objective>

<execution_context>
@/Users/medelman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medelman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-legal-chunking/05-RESEARCH.md
@.planning/phases/05-legal-chunking/05-CONTEXT.md
@.planning/phases/05-legal-chunking/05-01-SUMMARY.md
@lib/document-extraction/types.ts
@lib/document-extraction/structure-detector.ts
@lib/document-processing.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create legal chunker entry point, chunking strategies, and add forceLlm to structure detector</name>
  <files>lib/document-chunking/legal-chunker.ts, lib/document-chunking/chunk-strategies.ts, lib/document-extraction/structure-detector.ts</files>
  <action>
**Update `lib/document-extraction/structure-detector.ts` to support `forceLlm` option:**

Add an optional options parameter to `detectStructure`:

```typescript
export async function detectStructure(
  text: string,
  options?: { forceLlm?: boolean }
): Promise<DocumentStructure>
```

When `options?.forceLlm` is true, skip the regex check and go directly to the LLM path (`detectStructureWithLlm`). This is needed so the chunker can request LLM-based structure detection when regex-based structure is insufficient. The existing call sites (which pass no options) continue to work unchanged.

Implementation: Add this near the top of the function body:
```typescript
const useLlm = options?.forceLlm || !OBVIOUS_HEADING_PATTERNS.some((p) => p.test(text))
if (useLlm) {
  const llmResult = await detectStructureWithLlm(text)
  // ... rest of existing LLM path
} else {
  // ... existing regex path
}
```

**Create `lib/document-chunking/legal-chunker.ts`:**

This is the main entry point that replaces `chunkDocument()`. It consumes `DocumentStructure` from Phase 3 and produces `LegalChunk[]`.

```typescript
export async function chunkLegalDocument(
  text: string,
  structure: DocumentStructure,
  options?: Partial<LegalChunkOptions>
): Promise<LegalChunk[]>
```

Implementation flow:
1. Initialize Voyage AI tokenizer (call `initVoyageTokenizer()` once)
2. Merge options with defaults: `{ maxTokens: 512, targetTokens: 400, overlapTokens: 50, minChunkTokens: 50, skipBoilerplateEmbedding: true }`
3. **Validate structure quality** before chunking:
   - Check that all section positions are within text bounds (`startOffset >= 0 && endOffset <= text.length`)
   - Check for overlapping sections (section[i].endOffset > section[i+1].startOffset) -- log warning if found
   - Check for large gaps between sections (> 20% of text not covered by any section) -- log warning if found
   - If any section positions are out of bounds, clamp them to valid range and log a warning
4. Determine `structureSource`: check if structure came from regex or LLM. If `structure.sections.length === 0`, this is unstructured -- use fallback strategy on the entire text.
5. **CHK-03: LLM re-chunking when structure is insufficient.** Phase 3's `detectStructure()` already handles LLM fallback when regex finds no headings. The chunker adds a SECOND quality gate: after initial chunking with the provided structure, if structure quality is poor, request LLM re-analysis:
   - If `structure.sections` is empty (no structure detected at all), OR
   - If the chunk count / page ratio is < 2 (estimate pages as `Math.ceil(text.length / 3000)`, typical page is ~3000 chars)

   Then: call `detectStructure(text, { forceLlm: true })` to get LLM-based structure, and re-chunk using the LLM result. Log: `"Structure quality insufficient (${chunks.length} chunks for ~${pages} pages), requesting LLM re-analysis"`. Set `structureSource: 'llm'` on all resulting chunks.

   This satisfies CHK-03 (Use LLM for boundary detection when ambiguous) by combining Phase 3's existing LLM fallback with the chunker's quality threshold check.
6. Iterate over `structure.sections` and dispatch to appropriate strategy based on `section.type`:
   - `'definitions'` -> `chunkDefinitions(section, text, options)`
   - `'clause'` or `'heading'` -> `chunkClause(section, text, options)`
   - `'signature'` -> `chunkBoilerplate(section, text, options)`
   - `'exhibit'` -> `chunkExhibit(section, text, options)`
   - `'cover_letter'` -> `chunkBoilerplate(section, text, options)`
   - `'schedule'` -> `chunkExhibit(section, text, options)` (treat like exhibit)
   - `'amendment'` -> `chunkClause(section, text, options)` (treat like clause)
   - `'other'` -> `chunkClause(section, text, options)`
7. Handle text between detected sections (gaps): if there is text between `section[i].endOffset` and `section[i+1].startOffset`, chunk it as `chunkFallback()`.
8. Also handle text before first section and after last section as fallback chunks.
9. Post-process: call `mergeShortChunks()` then `splitOversizedChunks()` (import from chunk-merger.ts)
10. Annotate cross-references on all chunks (call `extractCrossReferences` for each chunk content, store in metadata.references)
11. Add overlap: for each chunk (except the first), prepend up to `overlapTokens` tokens from the end of the previous chunk. Set `metadata.isOverlap = true` and `metadata.overlapTokens = N`. IMPORTANT: the overlap text is prepended to `content` for embedding quality, but `startPosition`/`endPosition` track the ORIGINAL text positions (not including overlap).
12. Re-index all chunks sequentially (index = 0, 1, 2...) and assign `id = 'chunk-{index}'`
13. Return the final `LegalChunk[]`

**Create `lib/document-chunking/chunk-strategies.ts`:**

Import `PositionedSection` from `@/lib/document-extraction/types` and `LegalChunk`, `ChunkType`, `LegalChunkOptions` from `./types`. Import `countVoyageTokensSync` from `./token-counter`.

**`chunkDefinitions(section, fullText, options)`:**
- Extract content: `fullText.slice(section.startOffset, section.endOffset)`
- Split on definition patterns: `/"([^"]+)"\s+(?:means|shall mean|refers to|has the meaning)/gi` and also smart quotes variants
- Each match becomes its own chunk with `chunkType: 'definition'`, `sectionPath: [...section.sectionPath, 'Definition: {term}']`
- If a definition exceeds maxTokens, it stays as-is (will be split in post-processing)
- Any text in the definitions section that doesn't match a definition pattern becomes a clause chunk (the section intro, e.g., "The following terms shall have the meanings...")
- Positions: `startPosition = section.startOffset + match.index`, `endPosition = startPosition + match[0].length`

**`chunkClause(section, fullText, options)`:**
- Extract content: `fullText.slice(section.startOffset, section.endOffset)`
- Check for lettered sub-clauses: pattern `\n\s*\(([a-z])\)\s+` or `\n\s*\(([ivx]+)\)\s+` (Roman numerals too)
- If sub-clauses found:
  - Extract intro text (content before first sub-clause marker)
  - If intro is non-trivial (> 20 chars), create a clause chunk for it
  - Each sub-clause becomes its own chunk with:
    - `chunkType: 'sub-clause'`
    - `sectionPath: [...section.sectionPath, '({letter})']`
    - `metadata.parentClauseIntro`: first 100 tokens (using countVoyageTokensSync to measure) of the section content, truncated at word boundary
  - Calculate positions relative to section.startOffset
- If no sub-clauses: create a single chunk with `chunkType: 'clause'`, `sectionPath: section.sectionPath`
- All positions track into original `fullText`

**`chunkBoilerplate(section, fullText, options)`:**
- Create chunk(s) with `chunkType: 'boilerplate'`
- If content exceeds maxTokens, split at paragraph boundaries
- Section path from section.sectionPath

**`chunkExhibit(section, fullText, options)`:**
- Create chunk(s) with `chunkType: 'exhibit'`
- If substantive (> 100 tokens), chunk normally like clauses
- If short, create single chunk

**`chunkRecital(section, fullText, options)`:**
- Check for WHEREAS/recital patterns in the section
- Each "WHEREAS" paragraph becomes its own chunk with `chunkType: 'recital'`
- If no WHEREAS pattern, chunk as single recital

**`chunkFallback(text, startOffset, options, sectionPath?)`:**
- For unstructured text or gaps between sections
- Split on paragraph boundaries (double newline)
- Each paragraph becomes a chunk with `chunkType: 'fallback'`
- If a paragraph exceeds maxTokens, split at sentence boundaries (period + space)
- Track positions relative to startOffset

All strategy functions return `LegalChunk[]`. They use `countVoyageTokensSync()` for token counting (the tokenizer will already be initialized by the time strategies run).

Set `metadata.isOverlap = false` and `metadata.overlapTokens = 0` as defaults in all strategy functions (overlap is added later in post-processing by the main chunker).
  </action>
  <verify>
`npx tsc --noEmit` passes. Manually inspect that:
- detectStructure accepts optional `{ forceLlm?: boolean }` parameter
- chunkLegalDocument is exported and accepts (text, structure, options?)
- chunkLegalDocument validates structure positions (bounds check, overlap check, gap check)
- chunkLegalDocument triggers LLM re-chunking when structure.sections is empty OR chunk/page ratio < 2
- All strategy functions handle edge cases (empty sections, no matches)
- Positions reference the original fullText, not sliced content
  </verify>
  <done>
- detectStructure() updated with optional `{ forceLlm?: boolean }` parameter
- chunkLegalDocument() exported from legal-chunker.ts
- Structure quality validation: bounds checking, overlap detection, gap warnings
- CHK-03 satisfied: empty structure OR low chunk/page ratio triggers detectStructure({ forceLlm: true }) and re-chunk
- Six strategy functions exported from chunk-strategies.ts: chunkDefinitions, chunkClause, chunkBoilerplate, chunkExhibit, chunkRecital, chunkFallback
- Definitions split into one chunk per term
- Sub-clauses (a), (b), (c) each become their own chunk
- All chunks have correct chunkType, sectionPath, positions, and metadata
- Unstructured text falls back to paragraph-based splitting
  </done>
</task>

<task type="auto">
  <name>Task 2: Create post-processing modules (merger, cross-reference, chunk-map)</name>
  <files>lib/document-chunking/chunk-merger.ts, lib/document-chunking/cross-reference.ts, lib/document-chunking/chunk-map.ts</files>
  <action>
**Create `lib/document-chunking/chunk-merger.ts`:**

Two exported functions:

**`mergeShortChunks(chunks: LegalChunk[], minTokens: number): LegalChunk[]`**
- Iterate through chunks. If a chunk has `tokenCount < minTokens` (default 50):
  - Try to merge with the NEXT sibling chunk (same parent section path, adjacent index)
  - If next chunk also under target tokens after merge, do the merge
  - Merged chunk: combine content with `\n\n` separator, use earlier startPosition and later endPosition, set `chunkType: 'merged'`, combine sectionPaths (use the more specific one), sum tokenCounts
  - If no suitable merge candidate (e.g., last chunk, or next chunk is a different type), leave as-is
- Do NOT merge across different section paths at the top level (e.g., don't merge an Article 3 chunk with an Article 4 chunk)
- Do NOT merge chunks of type 'boilerplate' with non-boilerplate chunks

**`splitOversizedChunks(chunks: LegalChunk[], maxTokens: number): LegalChunk[]`**
- Iterate through chunks. If `tokenCount > maxTokens`:
  - Split at sentence boundaries (regex: `/(?<=[.!?])\s+/`)
  - Build sub-chunks by accumulating sentences until approaching maxTokens
  - Each sub-chunk inherits the parent's sectionPath and gets `chunkType: 'split'`
  - Positions: calculate from the parent chunk's startPosition using indexOf to find each sentence's offset
  - If no sentence boundaries found (one giant sentence), fall back to splitting at word boundaries at the maxTokens limit
- Re-count tokens using `countVoyageTokensSync()` for each resulting sub-chunk

**Create `lib/document-chunking/cross-reference.ts`:**

Single exported function:

**`extractCrossReferences(text: string): string[]`**
- Apply these regex patterns to extract section references:
  - `Section\s+(\d+(?:\.\d+)*)`
  - `Article\s+([IVX\d]+)`
  - `(?:paragraph|clause)\s+(\d+(?:\.\d+)*(?:\([a-z]\))?)`
  - `(?:as defined in|pursuant to|in accordance with|subject to)\s+Section\s+(\d+(?:\.\d+)*)`
- Deduplicate using a Set
- Return sorted array of unique references
- Handle edge case: don't extract self-references (would need chunk's own section path, but for simplicity, extract all and let downstream consumers filter)

**Create `lib/document-chunking/chunk-map.ts`:**

Two exported functions:

**`generateChunkMap(chunks: LegalChunk[], documentId: string): ChunkMap`**
- Compute:
  - `totalChunks`: chunks.length
  - `avgTokens`: Math.round(sum / count)
  - `minTokens`: Math.min(...)
  - `maxTokens`: Math.max(...)
  - `distribution`: count per chunkType
  - `entries`: array of ChunkMapEntry with index, sectionPath, type, tokenCount, preview (first 100 chars)
- Return ChunkMap object

**`computeChunkStats(chunks: LegalChunk[]): ChunkStats`**
- Same stats as chunk map but without entries list (lightweight for DB storage):
  - totalChunks, avgTokens, minTokens, maxTokens, distribution
- Return ChunkStats object (matches the type from types.ts)

Handle edge cases:
- Empty chunks array: return zeroed stats
- Single chunk: min = max = avg
  </action>
  <verify>
`npx tsc --noEmit` passes. Verify all five files in `lib/document-chunking/` compile cleanly. Ensure mergeShortChunks and splitOversizedChunks maintain position accuracy.
  </verify>
  <done>
- mergeShortChunks() merges chunks under 50 tokens with adjacent siblings
- splitOversizedChunks() splits chunks over 512 tokens at sentence boundaries
- extractCrossReferences() detects Section/Article/clause references
- generateChunkMap() produces complete chunk map with entries
- computeChunkStats() produces lightweight stats for DB storage
- All functions handle edge cases (empty input, single item)
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors across all 5 new files + updated structure-detector.ts
2. `detectStructure(text)` still works without options (backward compatible)
3. `detectStructure(text, { forceLlm: true })` forces LLM path
4. `chunkLegalDocument()` validates structure quality (positions within bounds, no overlaps, gap warnings)
5. `chunkLegalDocument()` triggers LLM re-chunking when structure.sections is empty OR chunk/page ratio < 2
6. All strategy functions handle their respective section types
7. Post-processing correctly merges short chunks and splits oversized ones
8. Cross-references are extracted from legal text patterns
9. Chunk map produces valid summary with stats
</verification>

<success_criteria>
- chunkLegalDocument() is the single entry point for legal-aware chunking
- CHK-03 satisfied: LLM re-chunking triggered when structure is insufficient (empty sections OR low chunk/page ratio)
- Structure quality validation catches out-of-bounds positions and overlapping sections
- detectStructure() accepts optional forceLlm parameter (backward compatible)
- Definitions produce one chunk per defined term
- Sub-clauses (a), (b), (c) produce one chunk each with parentClauseIntro metadata
- No chunk exceeds 512 Voyage AI tokens after post-processing
- Short chunks under 50 tokens are merged with adjacent siblings
- Cross-references annotated in chunk metadata
- Chunk map and stats generated for monitoring
- Boilerplate/signature sections chunked but marked appropriately
- Unstructured text falls back to paragraph-based splitting
</success_criteria>

<output>
After completion, create `.planning/phases/05-legal-chunking/05-02-SUMMARY.md`
</output>
