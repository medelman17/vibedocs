---
phase: 01-foundation-hardening
plan: 03
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - inngest/functions/analyze-nda.ts
  - db/schema/analyses.ts
  - db/migrations/add-clause-extraction-constraint.sql
autonomous: true

must_haves:
  truths:
    - "Pipeline halts with clear error when validation gate fails"
    - "Database writes use upsert patterns - retrying a step does not create duplicate records"
    - "Validation failures surface as user-visible errors (not silent progression)"
    - "Analysis record has status='failed' when validation fails"
  artifacts:
    - path: "inngest/functions/analyze-nda.ts"
      provides: "Pipeline with validation gates and idempotent writes"
      contains: "validateParserOutput"
    - path: "db/schema/analyses.ts"
      provides: "Unique constraint on clauseExtractions"
      contains: "unique"
  key_links:
    - from: "inngest/functions/analyze-nda.ts"
      to: "agents/validation"
      via: "imports validation gates"
      pattern: "import.*validateParserOutput.*validateClassifierOutput"
    - from: "inngest/functions/analyze-nda.ts"
      to: "inngest/utils/errors"
      via: "imports NonRetriableError"
      pattern: "NonRetriableError"
---

<objective>
Integrate validation gates and implement idempotent database writes in the pipeline.

Purpose: This plan wires together the validation infrastructure (Plan 01) into the analyze-nda.ts pipeline, adds upsert patterns for safe retries, and ensures validation failures become user-visible errors with proper status tracking.

Output:
- analyze-nda.ts with validation gates after parser and classifier steps
- Upsert patterns for analysis creation and clause persistence
- Unique constraint on clauseExtractions table for idempotent inserts
</objective>

<execution_context>
@/Users/medelman/.claude/get-shit-done/workflows/execute-plan.md
@/Users/medelman/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-hardening/01-RESEARCH.md (validation gate integration, upsert patterns)
@.planning/phases/01-foundation-hardening/01-01-SUMMARY.md (validation gate exports)
@.planning/phases/01-foundation-hardening/01-02-SUMMARY.md (migrated agents)

Source files to modify:
@inngest/functions/analyze-nda.ts
@db/schema/analyses.ts
@inngest/utils/errors.ts (NonRetriableError)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add unique constraint for clause extractions</name>
  <files>db/schema/analyses.ts</files>
  <action>
Add unique constraint on clauseExtractions table for idempotent inserts.

1. **Import unique from drizzle-orm/pg-core** (add to existing imports):
```typescript
import {
  pgTable,
  text,
  uuid,
  integer,
  real,
  index,
  jsonb,
  timestamp,
  unique,  // ADD THIS
} from "drizzle-orm/pg-core"
```

2. **Add unique constraint to clauseExtractions table definition** (in the index array at the bottom of the table):
```typescript
// Add after existing indexes in the clauseExtractions table:
/**
 * Unique constraint for idempotent clause inserts.
 * Each chunk should produce at most one extraction per analysis.
 * Enables ON CONFLICT DO UPDATE for safe retries.
 */
unique("clause_analysis_chunk").on(table.analysisId, table.chunkId),
```

This constraint ensures that retrying the classifier step doesn't create duplicate clause extractions - the same (analysisId, chunkId) pair can only exist once.
  </action>
  <verify>
```bash
# Unique constraint added
grep -q 'unique("clause_analysis_chunk")' db/schema/analyses.ts
# Import added
grep -q "unique" db/schema/analyses.ts | head -5
# TypeScript compiles
cd /Users/medelman/GitHub/medelman17/vibedocs && pnpm exec tsc --noEmit db/schema/analyses.ts 2>&1 | head -10
```
  </verify>
  <done>clauseExtractions has unique constraint on (analysisId, chunkId) for idempotent inserts</done>
</task>

<task type="auto">
  <name>Task 2: Integrate validation gates and upserts into pipeline</name>
  <files>inngest/functions/analyze-nda.ts</files>
  <action>
Update analyze-nda.ts to integrate validation gates and upsert patterns.

1. **Add imports** (at top of file):
```typescript
import { validateParserOutput, validateClassifierOutput } from '@/agents/validation'
import { NonRetriableError } from '@/inngest/utils/errors'
```

2. **Change analysis creation to upsert pattern** (Step 1, around line 49):

The current code uses `insert().returning()` which creates new records on retry. Change to pre-generate ID:

```typescript
// Step 1: Create or update analysis record (idempotent)
// Generate ID outside step for consistency across retries
const analysisId = crypto.randomUUID()

await step.run('create-analysis', async () => {
  await ctx.db
    .insert(analyses)
    .values({
      id: analysisId,
      documentId,
      tenantId,
      status: 'processing',
      progressStage: 'parsing',
      progressPercent: 0,
    })
    .onConflictDoUpdate({
      target: analyses.id,
      set: {
        status: 'processing',
        progressStage: 'parsing',
        progressPercent: 0,
        updatedAt: new Date(),
      },
    })
})
```

Note: This requires importing `analyses.id` conflict target capability. Drizzle supports this via the id column.

3. **Add parser validation gate** (after parser step, around line 100):

```typescript
// Step 2: Parser Agent
const parserResult = await step.run('parser-agent', () =>
  runParserAgent({ documentId, tenantId, source, content, metadata })
)

// Parser validation gate - runs AFTER step completes, OUTSIDE step.run()
const parserValidation = validateParserOutput(
  parserResult.document.rawText,
  parserResult.document.chunks
)
if (!parserValidation.valid) {
  // Persist failure state
  await step.run('mark-parser-failed', async () => {
    await ctx.db
      .update(analyses)
      .set({
        status: 'failed',
        progressStage: 'failed',
        metadata: {
          failedAt: 'parsing',
          errorCode: parserValidation.error!.code,
          errorMessage: parserValidation.error!.userMessage,
        },
      })
      .where(eq(analyses.id, analysisId))
  })
  // Throw non-retriable error with user-friendly message
  throw new NonRetriableError(parserValidation.error!.userMessage)
}

await emitProgress(
  'parsing',
  20,
  `Parsed ${parserResult.document.chunks.length} chunks`
)
```

4. **Add classifier validation gate** (after classifier step, around line 120):

```typescript
// Step 3: Classifier Agent
const classifierResult = await step.run('classifier-agent', () =>
  runClassifierAgent({
    parsedDocument: parserResult.document,
    budgetTracker,
  })
)

// Classifier validation gate - 0 clauses = always halt (per CONTEXT.md)
const classifierValidation = validateClassifierOutput(classifierResult.clauses)
if (!classifierValidation.valid) {
  await step.run('mark-classifier-failed', async () => {
    await ctx.db
      .update(analyses)
      .set({
        status: 'failed',
        progressStage: 'failed',
        metadata: {
          failedAt: 'classifying',
          errorCode: classifierValidation.error!.code,
          errorMessage: classifierValidation.error!.userMessage,
        },
      })
      .where(eq(analyses.id, analysisId))
  })
  throw new NonRetriableError(classifierValidation.error!.userMessage)
}

await emitProgress(
  'classifying',
  45,
  `Classified ${classifierResult.clauses.length} clauses`
)
```

5. **Important**: Keep validation OUTSIDE step.run() so failures trigger NonRetriableError immediately without Inngest retry logic.
  </action>
  <verify>
```bash
# Validation imports added
grep -q "validateParserOutput" inngest/functions/analyze-nda.ts
grep -q "validateClassifierOutput" inngest/functions/analyze-nda.ts
# NonRetriableError import
grep -q "NonRetriableError" inngest/functions/analyze-nda.ts
# Upsert pattern used
grep -q "onConflictDoUpdate" inngest/functions/analyze-nda.ts
# TypeScript compiles
cd /Users/medelman/GitHub/medelman17/vibedocs && pnpm exec tsc --noEmit inngest/functions/analyze-nda.ts 2>&1 | head -20
```
  </verify>
  <done>analyze-nda.ts has validation gates after parser/classifier steps and uses upsert for analysis creation</done>
</task>

<task type="auto">
  <name>Task 3: Push schema changes to database</name>
  <files>db/schema/analyses.ts</files>
  <action>
Run Drizzle schema push to apply the unique constraint to the database.

Execute:
```bash
cd /Users/medelman/GitHub/medelman17/vibedocs && pnpm db:push
```

This will add the `clause_analysis_chunk` unique constraint to the clauseExtractions table.

If the push fails due to existing duplicate data, the constraint may need to be added after cleaning up duplicates. Document any issues encountered.

Note: In local dev, `db:push` is safe. For production, this would need a proper migration.
  </action>
  <verify>
```bash
# Schema push completes (or document why it failed)
cd /Users/medelman/GitHub/medelman17/vibedocs && pnpm db:push 2>&1 | tail -20
```
  </verify>
  <done>Database schema updated with unique constraint (or documented blocker if existing data conflicts)</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Run `pnpm exec tsc --noEmit` to verify no type errors
2. Verify validation gates integrated: `grep -A5 "validateParserOutput" inngest/functions/analyze-nda.ts`
3. Run pipeline tests if they exist: `pnpm test inngest/functions/analyze-nda`
4. Verify unique constraint: `grep "clause_analysis_chunk" db/schema/analyses.ts`
</verification>

<success_criteria>
- analyze-nda.ts has validation gates after parser and classifier steps
- Validation failures trigger NonRetriableError with user-friendly message
- Analysis record set to status='failed' when validation fails
- Analysis creation uses upsert pattern with pre-generated ID
- clauseExtractions has unique constraint on (analysisId, chunkId)
- All TypeScript compilation passes
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-hardening/01-03-SUMMARY.md`
</output>
